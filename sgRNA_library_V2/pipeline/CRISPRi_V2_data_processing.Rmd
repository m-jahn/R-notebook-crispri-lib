---
title: "CRISPRi library V2, data processing pipeline"
output:
  html_notebook: 
    theme: cosmo
    toc: yes
    number_sections: true
---

----------

# Description

This R notebook details the data processing and visualization for growth competition experiments with a CRISPRi sgRNA library. The library contains around 20,000 unique sgRNA repression mutants tailored for the cyanobacterium _Synechocystis_ sp. PCC6803. This library is the second version (therefore "V2") of an sgRNA library for _Synechocystis_, containing 5 instead of only 2 sgRNAs per gene if possible. Some genes or ncRNAs are very short and hence it was no possible to design the maximum number of individual sgRNAs. The first iteration of the library was [published in Nature Communications, 2020](https://www.nature.com/articles/s41467-020-15491-7).

# Quality control

## Data import

Load required packages.

```{r, message = FALSE }
library(tidyverse)
library(lattice)
library(latticeExtra)
library(latticetools)
library(scales)
```

Load raw data. The main table contains already normalized quantification of all sgRNAs, fold change, multiple hypothesis corrected p-values, and fitness score. Contrary to the processing of [our first CRISPRi library V1](https://github.com/m-jahn/R-notebooks), much of the functionality from the notebook was transferred into the [new CRISPRi library pipeline on github](https://github.com/m-jahn/CRISPRi-lib-pipe).

```{r}
load("../data/input/DESeq2_result.Rdata", )
df_main <- DESeq_result_table; rm(DESeq_result_table)
```


```{r, echo = FALSE}
# custom ggplot2 theme that is reused for all later plots
custom_colors = c("#E7298A", "#66A61E", "#E6AB02", "#7570B3", "#666666", "#1B9E77", "#D95F02", "#A6761D")
custom_theme <- function(base_size = 12, base_line_size = 1.0, base_rect_size = 1.0, ...) {
  theme_light(base_size = base_size, base_line_size = base_line_size, base_rect_size = base_rect_size) + theme(
    plot.margin = unit(c(12,12,12,12), "points"),
    axis.ticks.length = unit(0.2, "cm"),
    axis.ticks = element_line(colour = grey(0.4), linetype = "solid", lineend = "round"),
    axis.text.x = element_text(colour = grey(0.4), size = 10),
    axis.text.y = element_text(colour = grey(0.4), size = 10),
    panel.grid.major = element_line(size = 0.6, linetype = "solid", colour = grey(0.9)),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(linetype = "solid", colour = grey(0.4), fill = NA, size = 1.0),
    panel.background = element_blank(),
    strip.background = element_rect(fill = grey(0.4), colour = grey(0.4)),
    strip.text = element_text(colour = "white", size = 10, margin = unit(rep(3,4), "points")),
    legend.text = element_text(colour = grey(0.4), size = 10),
    legend.title = element_text(colour = grey(0.4), size = 10),
    ...
  )
}
```


## Data annotation

Different annotation columns are added to the main data frame, including a short sgRNA identifier (excluding the position on the gene), an sgRNA index (1 to 5), and genome annotation from Uniprot. Note: The Uniprot data can also be dynamically downloaded for every update of this pipeline using their very simple API:
`read_tsv("https://www.uniprot.org/uniprot/?query=taxonomy:1111708&format=tab")`.

```{r, message = FALSE}
df_main <- df_main %>%
  # correct an error in sgRNA naming
  mutate(sgRNA = gsub('”', '2', sgRNA)) %>%
  # split sgRNA names into target gene and position
  separate(sgRNA, into = c("sgRNA_target", "sgRNA_position"), sep = "\\|",
    remove = FALSE) %>%
  
  # add sgRNA index number (1 to maximally 5) and type
  group_by(sgRNA_target) %>%
  mutate(
    sgRNA_index = sgRNA_position %>% as.numeric %>% as.factor %>%
    as.numeric,
    sgRNA_type = if_else(grepl("^nc_", sgRNA), "ncRNA", "gene")) %>%

  # map trivial names to LocusTags using a manually curated list
  left_join(
    read_tsv("../data/input/mapping_trivial_names.tsv", col_types = cols()),
    by = c("sgRNA_target" = "gene")) %>%
  
  # one more join, this time with the annotation db
  # containing uniprot and categorial (KEGG Brite) data
  left_join(read_csv("../../sgRNA_library/raw_data/Synechocystis_PCC6803_genome_annotation_20190614.csv")[c(1,4:6,11,20,22,27:32)], 
    by = c("locus" = "GeneID")) %>% ungroup %>%
  
  # remove some empty rows (NA targets)
  filter(!is.na(sgRNA_target))

head(df_main)
```


## Number of sgRNAs

Each gene is represented by up to five sgRNAs. We can test if all or only some of the 5 sgRNAs are "behaving" in the same way in the same conditions, more mathematically speaking we can estimate the correlation of every sgRNA with another. First let's summarize how many genes have 5, 4, 3 sgRNAs and so on associated with them.

```{r, , fig.width = 6, fig.height = 3.5, message =FALSE}
# N unique sgRNAs in dataset
paste0("Number of unique sgRNAs: ", unique(df_main$sgRNA) %>% length)

# N genes with 1,2,3,4 or 5 sgRNAs
df_main %>%
  group_by(sgRNA_type, sgRNA_target) %>%
  summarize(n_sgRNAs = length(unique(sgRNA_position))) %>%
  count(n_sgRNAs) %>% filter(n_sgRNAs <= 5) %>%
  ggplot(aes(x = factor(n_sgRNAs), y = n, fill = factor(n_sgRNAs),
    label = n)) +
  geom_col(show.legend = FALSE) +
  geom_text(size = 3, nudge_y = 100) +
  facet_grid(~sgRNA_type) +
  custom_theme() +
  scale_fill_manual(values = custom_colors)
```

## Correlation of sgRNAs

Different methods can be used to estimate similarity between samples (sgRNAs). For example, factor analysis is a method to dissect underlying sources of variation within the dataset, and the contribution to overall variation. The most famous example is principal component analysis (PCA). More simple is to use the correlation coefficient of sgRNAs to each other to see if one of the sgRNAs contributes stronger to overall variation.

This is an example of an apparently strictly essential gene, encoding the ribosomal protein `rps10`. Most of the sgRNA repressor strains are depleted, the correlation between sgRNAs is high. The strength of depletion varies though, and the strain with sgRNA 3 is not depleted at all. We want to give higher weights to sgRNAs that correlate well with each other, and/or show stronger effect (depletion/enrichment).

```{r, fig.width = 8, fig.height = 4}
df_main %>% filter(sgRNA_target == "rps10") %>%
  mutate(sgRNA_index = factor(sgRNA_index)) %>%
  ggplot(aes(x = time, y = log2FoldChange, color = sgRNA_index)) +
  geom_line(size = 1) + geom_point(size = 2) +
  facet_wrap(~ condition, ncol = 4) +
  custom_theme() +
  scale_color_manual(values = custom_colors)
```

A correlation score can be calculated by computing the correlation coefficient of all sgRNAs to each other. This score is robustly summarized by taking the median, and rescaling it from the respective minima and maxima [-1, 1] to [0, 1]. This score serves as a weight for each sgRNA to calculate the (global) weighted mean of log2 FC over all sgRNAs. The score has the characteristic that it gives a weight of 1 for an sgRNA perfectly correlated with all other sgRNAs of the same gene, and a weight of 0 for sgRNAs perfectly anti-correlated to the other sgRNAs.

For a matrix of $x = 1 .. m$ sgRNAs and $y = 1 .. n$ observations (measurements), the correlation $R$ of one sgRNA to another is calculated using Pearson's method:

$R_x=cor([log_2FC_{x1,y1} ... log_2FC_{x1,yn}], [log_2FC_{x2,y1} ... log_2FC_{x2,yn}])$

The weight of one sgRNA is then calculated as median of all $R$ rescaled between 0 and 1.

$w_x = \frac{1 + median(R_1, R_2, ..., R_m)}{2}$

The following example shows the correlation matrix for the 5 `rps10` sgRNAs, and their weights. The self correlation of each sgRNA (R = 1) is removed prior to weight determination.

```{r, fig.width = 4, fig.height = 4}
cor_matrix <- df_main %>% filter(sgRNA_target == "rps10") %>% ungroup %>%
  select(sgRNA_index, log2FoldChange, group) %>%
  pivot_wider(names_from = group, values_from = log2FoldChange) %>%
  arrange(sgRNA_index) %>% column_to_rownames("sgRNA_index") %>%
  as.matrix %>% t %>% cor(method = "pearson")

weights <- cor_matrix %>% replace(., . == 1, NA) %>%
  apply(2, function(x) median(x, na.rm = TRUE)) %>%
  rescale(from = c(-1, 1), to = c(0, 1))

# plot heatmap
lattice::levelplot(cor_matrix %>% replace(., . == 1, NA),
  col.regions = colorRampPalette(custom_colors[c(1,5,2)])(20))

# print weights
weights
```

----------

Now we can create a function that will compute weights for all sgRNAs, and add the weights to the data set.

```{r, warning = FALSE}
determine_weight <- function(index, value, group) {
  # make correlation matrix
  df <- data.frame(index = index, value = value, group = group)
  cor_matrix <- pivot_wider(df, names_from = group, values_from = value) %>%
    arrange(index) %>% column_to_rownames("index") %>%
    as.matrix %>% t %>% cor(method = "pearson")
  
  # determine weights
  weights <- cor_matrix %>% replace(., . == 1, NA) %>%
    apply(2, function(x) median(x, na.rm = TRUE)) %>%
    scales::rescale(from = c(-1, 1), to = c(0, 1)) %>%
    enframe("index", "weight") %>% mutate(index = as.numeric(index)) %>%
    mutate(weight = replace(weight, is.na(weight), 1))
  
  # return vector of weights the same order and length 
  # as sgRNA index vector
  left_join(df, weights, by = "index") %>% pull(weight)
}

df_main <- df_main %>%
  group_by(sgRNA_target) %>%
  mutate(sgRNA_weight = determine_weight(sgRNA_index, log2FoldChange, group))
```


## Efficiency of sgRNAs

The correlation of each sgRNA with each other is a "global" parameter as it is identical over all conditions. A second global parameter, **sgRNA efficiency**, can be obtained using a similar approach. We expect that fitness of all sgRNAs for one gene is not normally distributed because sgRNAs are not ideal replicate measurements. They are biased by position effects and off-target binding, see [Wang et al., Nature Comms, 2018](https://www.nature.com/articles/s41467-018-04899-x) for a very insightful and comprehensive analysis of the number and position of sgRNAs required to estimate gene fitness. 

We calculate sgRNA efficiency $E$ as the median absolute fitness (AUC of log2FC over time) of an sgRNA $x = 1 .. m$ over all observations [conditions] $y = 1 .. n$.

$E_x=median(abs(fitness_{x1, y1}, fitness_{x1, y2}, ..., fitness_{x1, yn}))$

To normalize between all sgRNAs, $E$ is rescaled to a range between 0 and 1.

$E_x=\frac{E_x}{max(E_1, E_2, ..., E_m)}$

```{r}
df_main <- df_main %>% group_by(sgRNA_target) %>%
  mutate(sgRNA_efficiency = ave(fitness, sgRNA_index, FUN = function(x) median(abs(x))) %>%
    {./max(.)})
```

This is the resulting sgRNA efficiency for the example gene above, `rps10`.

```{r}
df_main %>% filter(sgRNA_target == "rps10") %>% ungroup %>%
  select(sgRNA_index, sgRNA_efficiency) %>% distinct %>% 
  arrange(sgRNA_index) %>% deframe
```


## Position bias of sgRNA repression

Plot the **weight of each sgRNA** to see if there is a dependency between correlation and sgRNA position. There is no significant trend.

```{r, fig.width = 5, fig.height = 4}
df_main %>%
  select(sgRNA_target, sgRNA_index, sgRNA_weight) %>%
  filter(sgRNA_index <= 5) %>%
  distinct %>%
  # plot
  ggplot(aes(x = factor(sgRNA_index), y = sgRNA_weight)) +
  geom_boxplot(outlier.shape = "") +
  stat_summary(fun.data = function(x) c(y = median(x)+0.07, 
    label = round(median(x), 2)), geom = "text") +
  stat_summary(fun.data = function(x) c(y = 1.2, 
    label = length(x)), geom = "text", color = grey(0.5)) +
  coord_cartesian(ylim = c(-0.25, 1.25)) +
  custom_theme()
```

We can also quantify how many genes have strongly correlated sgRNAs and how many have outliers. In order to do this, the median weight of the (up to) 5 sgRNAs per gene is plotted. Generally, the median weight ranges between 0.5 and 1.0, showing on average good correlation.

```{r, fig.width = 5, fig.height = 4}
df_main %>%
  select(sgRNA_target, sgRNA_index, sgRNA_weight) %>%
  filter(sgRNA_index <= 5) %>%
  distinct %>% group_by(sgRNA_target) %>%
  summarize(
    median_sgRNA_weight = median(sgRNA_weight),
    min_sgRNA_weight = min(sgRNA_weight)
  ) %>%
  # plot
  ggplot(aes(x = median_sgRNA_weight)) +
  geom_histogram(bins = 40, fill = custom_colors[1], alpha = 0.7) +
  custom_theme()
```

Second, the binding position of the sgRNAs could be correlated to the strength of repression. In other words sgRNAs binding closer to the promoter could have stronger ability to repress a gene, see Figure 1 B in [Wang et al., Nature Comms, 2018](https://www.nature.com/articles/s41467-018-04899-x). We plot **sgRNA efficiency** for genes only, because the absolute majority of those has 5 sgRNAs.

```{r, fig.width = 5, fig.height = 4}
df_main %>%
  filter(sgRNA_index <= 5, sgRNA_type == "gene") %>%
  select(sgRNA_target, sgRNA_index, sgRNA_efficiency) %>% distinct %>%
  ggplot(aes(x = factor(sgRNA_index), y = sgRNA_efficiency)) +
  geom_boxplot(notch = FALSE, outlier.shape = ".") +
  coord_cartesian(ylim = c(-0.25, 1.25)) +
  stat_summary(fun.data = function(x) c(y = median(x)+0.07, 
    label = round(median(x), 2)), geom = "text") +
  stat_summary(fun.data = function(x) c(y = 1.2, 
    label = length(x)), geom = "text", color = grey(0.5)) +
  custom_theme()
```

## Summarize sgRNA fitness to gene fitness

With the correlation and the efficiency per sgRNA, we can compute the **weighted mean of all sgRNAs**. For comparison, we also test simple strategies such as the standard **arithmetic mean** and a top 1 and top 2 sgRNAs strategy. Metrics are calculated for log2 FC, and fitness.

```{r, warning = FALSE, message = FALSE}
df_gene <- df_main %>%
  
  # keep all annotation columns
  group_by(sgRNA_target, sgRNA_type, locus, condition, time, Process, 
    Pathway, Protein, Gene.names, Gene.ontology.IDs, Length, MolWeight,
    location, start_bp, end_bp) %>%
  
  # summarize FC and fitness...
  summarize(.groups = "drop",
    # log2 FC
    mean_log2FoldChange = mean(log2FoldChange),
    wmean_log2FoldChange = weighted.mean(log2FoldChange, sgRNA_weight * sgRNA_efficiency),
    top1_log2FoldChange = log2FoldChange[which.max(sgRNA_efficiency)],
    top2_log2FoldChange = mean(log2FoldChange[order(sgRNA_efficiency, decreasing = TRUE)[1:2]]),
    sd_log2FoldChange = sd(log2FoldChange),
    # fitness
    mean_fitness = mean(fitness),
    wmean_fitness = weighted.mean(fitness, sgRNA_weight * sgRNA_efficiency),
    top1_fitness = fitness[which.max(sgRNA_efficiency)],
    top2_fitness = mean(fitness[order(sgRNA_efficiency, decreasing = TRUE)[1:2]]),
    sd_fitness = sd(fitness)
  )
```

A comparison of log2 FC aggregated by the different method shows clear differences. For the example gene `rps10` the weighted mean and the top method give similar results, representative of the stronger influence from highly depleted sgRNA repression strains. The regular mean is robust, but "shallow", probably underestimating the real effect n fitness. The top 1 method simply picks the most depleted/enriched sgRNA (over all conditions) as representative.

```{r, fig.width = 8, fig.height = 4}
df_gene %>% filter(sgRNA_target == "rps10") %>%
  pivot_longer(cols = matches("[n12]_log2FoldChange"), names_to = "metric", values_to = "log2FoldChange") %>%
  mutate(metric = str_remove(metric, "_log2FoldChange")) %>%
  ggplot(aes(x = time, y = log2FoldChange, 
    ymin = log2FoldChange-sd_log2FoldChange, 
    ymax = log2FoldChange+sd_log2FoldChange, color = fct_inorder(metric))) +
  geom_line(size = 1) + geom_point(size = 2) + geom_linerange(size = 1) +
  facet_wrap(~ condition, ncol = 4) +
  custom_theme(legend.position = "right") +
  coord_cartesian(ylim = c(-3.75, 0.75)) +
  scale_color_manual(values = custom_colors)
```

This plot shows a comparison of the 4 methods for the first 36 genes by alphabetical order, for one selected condition only (1% CO2, BG11, 1,000 µmol photons m-1 s-1). Here we can see that the top1 method is often but not always representative for the gene: For apcD or apcF, it does not seem representative compared to the mean, weighted mean, and top2 methods.

```{r, fig.width = 9, fig.height = 9}
df_gene %>% filter(
    #str_detect(Gene.names, "rps"),
    Gene.names %in% unique(.data[["Gene.names"]])[1:36],
    condition == "1% CO2, BG11, 1000uE"
  ) %>%
  pivot_longer(cols = matches("[n12]_log2FoldChange"), names_to = "metric", values_to = "log2FoldChange") %>%
  mutate(metric = str_remove(metric, "_log2FoldChange")) %>%
  ggplot(aes(x = time, y = log2FoldChange, 
    ymin = log2FoldChange-sd_log2FoldChange,
    ymax = log2FoldChange+sd_log2FoldChange, color = fct_inorder(metric))) +
  geom_line(size = 1) + geom_point(size = 2) + geom_linerange(size = 1) +
  facet_wrap(~ sgRNA_target, ncol = 6) +
  custom_theme(legend.position = "top") +
  coord_cartesian(ylim = c(-5, 5)) +
  scale_color_manual(values = custom_colors)
```

The same control can be performed for gene fitness, that is, the AUC of log2 FC over all time points, for each individual sgRNA. Fitness was also summarized using the mean, weighted mean, or a top1 and top2 method for each of the 36 first genes by alphabetical order and one selected condition only. We can conclude from the plot below that mean and weighted mean only result in marginal difference in estimation of fitness, and continue with the weighted versions for all following analyses.

```{r, fig.width = 9, fig.height = 4.5}
df_gene %>% filter(
    #str_detect(Gene.names, "rps"),
    Gene.names %in% unique(.data[["Gene.names"]])[1:36],
    condition == "1% CO2, BG11, 1000uE"
  ) %>%
  pivot_longer(cols = matches("[n12]_fitness"), names_to = "metric", values_to = "fitness") %>%
  mutate(metric = str_remove(metric, "_fitness")) %>% distinct %>%
  ggplot(aes(x = sgRNA_target, y = fitness, 
    ymin = fitness-sd_fitness, 
    ymax = fitness+sd_fitness, fill = fct_inorder(metric), color = fct_inorder(metric))) +
  geom_col(position = "dodge") +
  geom_errorbar(position = "dodge", size = 1) +
  custom_theme(legend.position = "top") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_fill_manual(values = custom_colors[1:4]) +
  scale_color_manual(values = custom_colors[1:4])
```

## Global distribution of gene fitness

```{r, fig.width = 8, fig.height = 4}
df_gene %>% filter(time == 0) %>%
  ggplot(aes(x = wmean_fitness, fill = sgRNA_type)) +
  geom_histogram(bins = 100) +
  coord_cartesian(xlim = c(-2, 2), ylim = c(0, 1000)) +
  facet_wrap( ~ condition, ncol = 4) +
  custom_theme() +
  scale_fill_manual(values = custom_colors[3:4])
```


## Behavior of control sgRNAs

Ten sgRNAs were included in the library that have no gene-specific/random (?) targets. The following plot shows that these negative controls do not have an effect on strain fitness, except probably 2 sgRNAs in one specific condition.

```{r, fig.width = 8, fig.height = 4}
df_main %>% filter(grepl("ctrl", sgRNA_target)) %>%
  ggplot(aes(x = time, y = log2FoldChange, color = sgRNA_target)) +
  geom_line(size = 1) + geom_point(size = 2) + ylim(-5, 5) +
  facet_wrap(~ condition, ncol = 4) +
  custom_theme() +
  scale_color_manual(values = rep_along(1:10, custom_colors))
```

# Unsupervised clustering of genes

## Cluster genes by similarity

```{r, fig.width = 8, fig.height = 5}
# library to work dendrograms
library(dendextend)

# generate colorpalette for heatmap
heat_cols <- colorspace::diverging_hcl(n = 7, h = c(255, 12), c = c(50, 80), l = c(20, 97), power = c(1, 1.3))

# create a matrix-like df with wide fitness data for plotting heatmap
df_heatmap <- df_gene %>% filter(time == 0, !is.na(locus)) %>%
  select(locus, condition, wmean_fitness) %>%
  mutate(wmean_fitness = wmean_fitness %>%
    replace(., . > 3, 3) %>% replace(., . < -3, 3)) %>%
  pivot_wider(names_from = condition, values_from = wmean_fitness) %>%
  column_to_rownames(var = "locus")


# create cluster for reordering
mat_cluster <- mat_heatmap %>% dist %>% hclust(method = "ward.D")
mat_heatmap <- mat_heatmap[order.dendrogram(as.dendrogram(mat_cluster)), c(1,3,2,4,6,5,7)]



#filter(if_any(.cols = matches("uE$"), ~ !between(., -1.5, 1.5))) %>%
#  as.matrix

plot_cluster_dend <- mat_cluster %>%
  as.dendrogram %>%
  set("branches_k_color", k = 5) %>%
  set("labels_cex", 0) %>%
  set("branches_lwd", 0.5) %>%
  as.ggdend %>%
  ggplot()
```


```{r, fig.width = 8, fig.height = 3}
# plot heatmap
plot_heatmap <- levelplot(mat_heatmap,
  par.settings = custom.colorblind(),
  col.regions = colorRampPalette(heat_cols)(16),
  at = seq(-3, 3, 0.5), aspect = "fill",
  xlab = paste0("sgRNA (", nrow(mat_heatmap),")"),
  ylab = "", scales = list(x = list(draw = FALSE)),
  panel = function(x, y, z, ...) {
    panel.levelplot(x, y, z, ...)
    panel.abline(h = 1:5+0.5, col = "white", lwd = 1.5)
  }
)

gridExtra::grid.arrange(
  # coords for unit: top, right, bottom, left
  plot_cluster_dend + 
    theme(plot.margin = unit(c(-1.5, 0.08, -0.4, 0.265),"npc")),
  plot_heatmap,
  nrow = 2
)
```
