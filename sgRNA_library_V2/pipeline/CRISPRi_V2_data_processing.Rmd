---
title: "CRISPRi library V2, data processing pipeline"
output:
  html_notebook:
    theme: cosmo
    toc: yes
    number_sections: yes
  html_document:
    toc: yes
    df_print: paged
---

----------

# Description

This R notebook details the data processing and visualization for growth competition experiments with a CRISPRi sgRNA library. The library contains around 20,000 unique sgRNA repression mutants tailored for the cyanobacterium _Synechocystis_ sp. PCC6803. This library is the second version (therefore "V2") of an sgRNA library for _Synechocystis_, containing five instead of only two sgRNAs per gene. In some cases, genes or ncRNAs are so short that it is not possible to design a maximum of five individual sgRNAs.

The first iteration of the _Synechocystis_ sgRNA library was [published in Nature Communications, 2020](https://www.nature.com/articles/s41467-020-15491-7).

# Quality control

## Data import

Load required packages.

```{r, message = FALSE }
suppressPackageStartupMessages({
  library(tidyverse)
  library(ggrepel)
  library(lattice)
  library(latticeExtra)
  library(latticetools)
  library(scales)
  library(dendextend)
  library(vegan)
  library(tsne)
  library(KEGGREST)
  library(limma)
  library(corrplot)
  library(kableExtra)
  library(grid)
  library(ggpubr)
})
```

Load raw data. The main table contains already normalized quantification of all sgRNAs, fold change, multiple hypothesis corrected p-values, and fitness score. Contrary to the processing of [our first CRISPRi library V1](https://github.com/m-jahn/R-notebooks), much of the functionality from the notebook was transferred into the [new CRISPRi library pipeline on github](https://github.com/m-jahn/CRISPRi-lib-pipe).

```{r}
# load first seq run
load("../data/input/DESeq2_result.Rdata")
df_main <- DESeq_result_table

# load second seq run
load("../data/input/DESeq2_result_2.Rdata")
df_main <- bind_rows(df_main, DESeq_result_table)

# remove single results table
rm(DESeq_result_table)
```


```{r, echo = FALSE}
# custom ggplot2 theme that is reused for all later plots
custom_colors = c("#E7298A", "#66A61E", "#E6AB02", "#7570B3", "#666666", "#1B9E77", "#D95F02", "#A6761D")
custom_range <- function(n = 5) {colorRampPalette(custom_colors[c(1,5,2)])(n)}

custom_theme <- function(base_size = 12, base_line_size = 1.0, base_rect_size = 1.0, ...) {
  theme_light(base_size = base_size, base_line_size = base_line_size, base_rect_size = base_rect_size) + theme(
    title = element_text(colour = grey(0.4), size = 10),
    plot.margin = unit(c(12,12,12,12), "points"),
    axis.ticks.length = unit(0.2, "cm"),
    axis.ticks = element_line(colour = grey(0.4), linetype = "solid", lineend = "round"),
    axis.text.x = element_text(colour = grey(0.4), size = 10),
    axis.text.y = element_text(colour = grey(0.4), size = 10),
    panel.grid.major = element_line(size = 0.6, linetype = "solid", colour = grey(0.9)),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(linetype = "solid", colour = grey(0.4), fill = NA, size = 1.0),
    panel.background = element_blank(),
    strip.background = element_blank(),
    strip.text = element_text(colour = grey(0.4), size = 10, margin = unit(rep(3,4), "points")),
    legend.text = element_text(colour = grey(0.4), size = 10),
    legend.title = element_blank(),
    legend.background = element_blank(),
    ...
  )
}

# set graphical parameter for subfigure labels
list_fontpars <- list(face = "plain", size = 14)

# function to export an image as svg and png
save_plot <- function(pl, path = "../figures/", width = 6, height = 6) {
  pl_name <- deparse(substitute(pl))
  svg(filename = paste0(path, pl_name, ".svg"),
    width = width, height = height)
  print(pl)
  dev.off()
  png(filename = paste0(path, pl_name, ".png"),
    width = width*125, height = height*125, res = 120)
  print(pl)
  invisible(capture.output(dev.off()))
}
```


## Data annotation

Different annotation columns are added to the main data frame, including a short sgRNA identifier (excluding the position on the gene), an sgRNA index (1 to 5), and genome annotation from Uniprot. The Uniprot data is dynamically downloaded for every update of this pipeline using their very simple API (`read_tsv("https://www.uniprot.org/uniprot/?query=taxonomy:1111708&format=tab")`). The full list of columns that can be queried is available [here](https://www.uniprot.org/help/uniprotkb_column_names).
Pathway annotation from KEGG is later in the pipeline added using the `KEGGREST` package.

```{r, message = FALSE}
df_main <- df_main %>%
  # correct an error in sgRNA naming
  mutate(sgRNA = gsub('”', '2', sgRNA)) %>%
  # split sgRNA names into target gene and position
  separate(sgRNA, into = c("sgRNA_target", "sgRNA_position"), sep = "\\|",
    remove = FALSE) %>%
  
  # add sgRNA index number (1 to maximally 5) and type
  group_by(sgRNA_target) %>%
  mutate(
    sgRNA_position = as.numeric(sgRNA_position),
    sgRNA_index = sgRNA_position %>% as.factor %>% as.numeric,
    sgRNA_type = if_else(grepl("^nc_", sgRNA), "ncRNA", "gene")) %>%
  ungroup %>%
  
  # map trivial names to LocusTags using a manually curated list
  left_join(
    read_tsv("../data/input/mapping_trivial_names.tsv", col_types = cols()),
    by = c("sgRNA_target" = "gene")) %>%
  
  # remove some empty rows (NA targets)
  filter(!is.na(sgRNA_target)) %>%
  
  # remove 2 conditions without response
  filter(!condition %in% c("BG11", "LC, 200uE")) %>%
  
  # split condition into separate cols
  separate(condition, into = c("carbon", "light", "treatment_1", "treatment_2"),
    sep = ", ", remove = FALSE, fill = "right") %>%
  unite("treatment", treatment_1, treatment_2, sep = ", ", na.rm = TRUE)
```

Overview about the different conditions.

```{r}
df_cultivation_summary <- df_main %>% group_by(condition) %>%
  summarize(
    time_points = paste(unique(time), collapse = ", "),
    carbon = unique(carbon),
    light = unique(light),
    treatment = unique(treatment),
    min_fit = min(fitness),
    med_fit = median(fitness),
    max_fit = max(fitness))

print(df_cultivation_summary)
write_csv(df_cultivation_summary, file = "../data/output/cultivation_summary.csv")
```

Retrieve gene info from uniprot and merge with main data frame. We need to make a custom function to retrieve and parse the data from uniprot, because of a bug in the security level on Ubuntu 20.04. The fallback option is to load a local copy of uniprot annotation for this organism.

```{r}
library(httr)
uniprot_url <- paste0(
   "https://www.uniprot.org/uniprot/?query=taxonomy:1111708&format=tab&",
   "columns=id,genes,genes(PREFERRED),protein_names,length,mass,ec,database(KEGG)")

get_uniprot <- function(url) {
  # reset security level, caused by a faulty SSL certificate on server side,
  # see this thread: https://github.com/Ensembl/ensembl-rest/issues/427
  httr_config <- config(ssl_cipher_list = "DEFAULT@SECLEVEL=1")
  res <- with_config(config = httr_config, GET(url))
  server_error = simpleError("")
  df_uniprot <- tryCatch(
    read_tsv(content(res), col_types = cols()),
    error = function(server_error) {
      message("Uniprot server not available, falling back on local Uniprot DB copy")
      read_tsv("../data/input/uniprot_synechocystis.tsv", col_types = cols())
    }
  )
}

df_uniprot <- get_uniprot(uniprot_url) %>%
  rename_with(tolower) %>%
  rename(locus = `cross-reference (kegg)`, gene_name = `gene names`,
    gene_name_short = `gene names  (primary )`, ec_number = `ec number`,
    protein = `protein names`, uniprot_ID = entry
  ) %>%
  separate_rows(locus, sep = ";syn:") %>%
  mutate(locus = str_remove_all(locus, "syn:|;")) %>%
  filter(!is.na(locus))

df_main <- left_join(df_main, filter(df_uniprot, !duplicated(locus)),
  by = "locus")
```


## Number of sgRNAs

Each gene is represented by up to five sgRNAs. We can test if all or only some of the 5 sgRNAs are "behaving" in the same way in the same conditions, more mathematically speaking we can estimate the correlation of every sgRNA with another. First let's summarize how many genes have 5, 4, 3 sgRNAs and so on associated with them.

```{r, , fig.width = 6, fig.height = 3.5}
# N unique sgRNAs in dataset
paste0("Number of unique sgRNAs: ", unique(df_main$sgRNA) %>% length)

# N genes with 1,2,3,4 or 5 sgRNAs
plot_sgRNAs_per_gene <- df_main %>%
  group_by(sgRNA_type, sgRNA_target) %>%
  summarize(n_sgRNAs = length(unique(sgRNA_position)), .groups = "drop_last") %>%
  count(n_sgRNAs) %>% filter(n_sgRNAs <= 5) %>%
  ggplot(aes(x = factor(n_sgRNAs, 5:1), y = n, label = n)) +
  geom_col(show.legend = FALSE) +
  geom_text(size = 3, nudge_y = 200, color = grey(0.5)) +
  facet_grid(~ sgRNA_type) +
  labs(x = "n sgRNAs / target", y = "n targets") +
  coord_cartesian(ylim = c(-50, 3500)) +
  custom_theme() +
  scale_fill_manual(values = custom_colors)

print(plot_sgRNAs_per_gene)
save_plot(plot_sgRNAs_per_gene, width = 6, height = 3.5)
```

# Normalization

## Fitness distribution of all conditions

Before biological analysis continues, we need to check if fitness (and log2 FC from which it is calculated) is equally distributed. For example, strictly essential genes like ribosomal genes should show the same degreee of depletion over time, regardless of condition.

We can compare fitness over all conditions using a scatter plot matrix. We can see that some conditions are very similar to each other, for example the conditions treated with glucose (`LC, LL +g`, `LC, LL, +D, +G`, `HC, LL +g`). Others are more dissimilar to the rest, for example `LC, IL` and `LC, LL, +FL`. They are more alike each other, although `LC, LL, +FL` should be more comparable to `LC, LL`, hinting at experimental bias. In this case both of these conditions (and `LC, LL, +G`) were pre-cultivated in low light instead of high light, as opposed to the rest of the samples.

```{r, fig.width = 8, fig.height = 8}
df_main %>% filter(time == 0, sgRNA_index == 1) %>%
  select(locus, condition, fitness) %>%
  filter(!is.na(locus)) %>%
  pivot_wider(names_from = condition, values_from = fitness) %>%
  select(-locus) %>%
  custom_splom(pch = 19, cex = 0.3, col = grey(0.4, 0.4), pscales = 0)
```

## Normalization strategy

In order to account for experimental or quantification bias, we can try to normalize the log2 FC distribution between all samples, and then re-calculate fitness. The underlying assumption is that e.g. essential genes should deplete at the same rate and hence show identical log2 FC at identical time points. Different types of experimental bias influence global fitness distribution and should be reduced with normalization. Here we try a 'cyclic loess' or quantile normalization that gave good results in a quick comparison.

```{r, fig.width = 6, fig.height = 5}
# construct a normalization function that takes three colums as input,
# the numeric variable to be normalized, the conditioning variable
# (character or factor), and an ID that identifies each observation (sgRNA)
apply_norm = function(id, cond, var) {
  df_orig <- tibble(id = id, cond = cond, var = var)
  df_new <- pivot_wider(df_orig, names_from = cond, values_from = var) %>%
  column_to_rownames("id") %>% as.matrix %>%
  limma::normalizeBetweenArrays(method = "quantile") %>%
  as_tibble(rownames = "id") %>%
  pivot_longer(-id, names_to = "cond", values_to = "var_norm")
  left_join(df_orig, df_new, by = c("id", "cond")) %>% pull(var_norm)
}

# apply normalization
df_main <- df_main %>%
  mutate(FoldChange = 2^log2FoldChange) %>%
  group_by(time) %>%
  mutate(
    FoldChange_norm = apply_norm(sgRNA, condition, FoldChange),
    log2FoldChange = log2(FoldChange_norm)
  ) %>% ungroup

# compare effect of normalization
df_main %>% group_by(condition) %>% slice(1:10000) %>%
  ggplot(aes(x = log2(FoldChange), y = log2(FoldChange_norm), color = factor(time))) +
  geom_point(size = 0.5) +
  facet_wrap(~ condition, ncol = 4) +
  custom_theme() +
  scale_color_manual(values = custom_colors)
```

Another way to look at the result of the normalization is to compare the global distribution of log2 FC values, as a density plot.

```{r, fig.width = 6, fig.height = 5, warning = FALSE}
library(ggridges)
df_main %>% filter(time == 10) %>%
  select(sgRNA, condition, FoldChange, FoldChange_norm) %>%
  pivot_longer(matches("^Fold"), names_to = "metric", values_to = "FC") %>%
  distinct %>%
  ggplot(aes(x = log2(FC), y = condition, group = condition)) + 
  geom_density_ridges(fill = "#00AFBB99", col = grey(0.4)) +
  facet_wrap(~ metric, ncol = 4) +
  lims(x = c(-2, 1.5)) +
  custom_theme()
```

Now we need to re-calculate fitness based on the normalized log2 FC.

```{r}
df_main <- df_main %>%
  select(-FoldChange, -FoldChange_norm) %>%
  group_by(sgRNA, condition) %>%
  mutate(fitness = DescTools::AUC(time, log2FoldChange)/(max(time)/2)) %>%
  arrange(sgRNA_target, sgRNA_index, condition, time)
```

# Fitness score aggregation

## Correlation of sgRNAs

Different methods can be used to estimate similarity between samples (sgRNAs). For example, factor analysis is a method to dissect underlying sources of variation within the dataset, and the contribution to overall variation. The most famous example is principal component analysis (PCA). We can also use the correlation coefficient of sgRNAs to each other to see if one of the sgRNAs contributes stronger to overall variation.

This is an example of an apparently strictly essential gene, encoding the ribosomal protein `rps10`. Most of the sgRNA repressor strains are depleted, the correlation between sgRNAs is high. The strength of depletion varies though, and the strain with sgRNA 3 is not depleted at all. We want to give higher weights to sgRNAs that correlate well with each other, and/or show stronger effect (depletion/enrichment).

```{r, fig.width = 7, fig.height = 5.5}
plot_sgRNA_ribo_example <- df_main %>% filter(sgRNA_target == "rps10") %>%
  mutate(sgRNA_index = factor(sgRNA_index, 1:5)) %>%
  ggplot(aes(x = time, y = log2FoldChange, color = sgRNA_index)) +
  geom_line(size = 1) + geom_point(size = 2) +
  facet_wrap(~ condition, ncol = 4) +
  custom_theme() +
  scale_color_manual(values = custom_range(5))

print(plot_sgRNA_ribo_example)
save_plot(plot_sgRNA_ribo_example, width = 7, height = 5.5)
```

A correlation score can be calculated by computing the correlation coefficient of all sgRNAs to each other. This score is robustly summarized by taking the median, and rescaling it from the respective minima and maxima [-1, 1] to [0, 1]. This score serves as a weight component for each sgRNA to calculate the (global) weighted mean of log2 FC over all sgRNAs. The score has the characteristic that it gives a weight of 1 for an sgRNA perfectly correlated with all other sgRNAs of the same gene, and a weight of 0 for sgRNAs perfectly anti-correlated to the other sgRNAs.

For a matrix of $x = 1 .. m$ sgRNAs and $y = 1 .. n$ observations (measurements), the correlation $R$ of one sgRNA to another is calculated using Pearson's method:

$R_x=cor([log_2FC_{x1,y1} ... log_2FC_{x1,yn}], [log_2FC_{x2,y1} ... log_2FC_{x2,yn}])$

The correlation weight of one sgRNA is then calculated as median of all $R$ rescaled between 0 and 1.

$w_x = \frac{1 + median(R_1, R_2, ..., R_m)}{2}$

The following example shows the correlation matrix for the 5 `rps10` sgRNAs, and their weights. The self correlation of each sgRNA (R = 1) is removed prior to weight determination.

```{r, fig.width = 4, fig.height = 4}
cor_matrix <- df_main %>% filter(sgRNA_target == "rps10") %>% ungroup %>%
  select(sgRNA_index, log2FoldChange, condition, time) %>%
  pivot_wider(names_from = c("condition", "time"), values_from = log2FoldChange) %>%
  arrange(sgRNA_index) %>% column_to_rownames("sgRNA_index") %>%
  as.matrix %>% t %>% cor(method = "pearson")

weights <- cor_matrix %>% replace(., . == 1, NA) %>%
  apply(2, function(x) median(x, na.rm = TRUE)) %>%
  rescale(from = c(-1, 1), to = c(0, 1))

# plot heatmap
lattice::levelplot(cor_matrix %>% replace(., . == 1, NA),
  col.regions = custom_range(20))

# print weights
weights
```

----------

Now we can create a function that will compute weights for all sgRNAs, and add the weights to the data set.

```{r, warning = FALSE}
determine_corr <- function(index, value, condition, time) {
  # make correlation matrix
  df <- data.frame(index = index, value = value, condition = condition, time = time)
  cor_matrix <- pivot_wider(df, names_from = c("condition", "time"), values_from = value) %>%
    arrange(index) %>% column_to_rownames("index") %>%
    as.matrix %>% t %>% cor(method = "pearson")
  
  # determine weights
  weights <- cor_matrix %>% replace(., . == 1, NA) %>%
    apply(2, function(x) median(x, na.rm = TRUE)) %>%
    scales::rescale(from = c(-1, 1), to = c(0, 1)) %>%
    enframe("index", "weight") %>% mutate(index = as.numeric(index)) %>%
    mutate(weight = replace(weight, is.na(weight), 1))
  
  # return vector of weights the same order and length 
  # as sgRNA index vector
  left_join(df, weights, by = "index") %>% pull(weight)
}

df_main <- df_main %>%
  group_by(sgRNA_target) %>%
  mutate(sgRNA_correlation = determine_corr(sgRNA_index,
    log2FoldChange, condition, time))
```


## Efficiency of sgRNAs

The correlation of each sgRNA with each other is a "global" parameter as it is identical over all conditions. A second global parameter, **sgRNA efficiency**, can be obtained using a similar approach. We expect that fitness of all sgRNAs for one gene is not normally distributed because sgRNAs are not ideal replicate measurements. They are biased by position effects and off-target binding, see [Wang et al., Nature Comms, 2018](https://www.nature.com/articles/s41467-018-04899-x) for a very insightful and comprehensive analysis of the number and position of sgRNAs required to estimate gene fitness. 

We calculate sgRNA efficiency $E$ as the median absolute fitness (AUC of log2FC over time) of an sgRNA $x = 1 .. m$ over all observations [conditions] $y = 1 .. n$.

$E_x=median(abs(fitness_{x1, y1}, fitness_{x1, y2}, ..., fitness_{x1, yn}))$

To normalize between all sgRNAs, $E$ is rescaled to a range between 0 and 1.

$E_x=\frac{E_x}{max(E_1, E_2, ..., E_m)}$

```{r}
df_main <- df_main %>% group_by(sgRNA_target) %>%
  mutate(sgRNA_efficiency = ave(fitness, sgRNA_index, FUN = function(x) median(abs(x))) %>%
    {./max(.)})
```

This is the resulting sgRNA efficiency for the example gene above, `rps10`.

```{r}
df_main %>% filter(sgRNA_target == "rps10") %>% ungroup %>%
  select(sgRNA_index, sgRNA_efficiency) %>% distinct %>% 
  arrange(sgRNA_index) %>% deframe
```


## Position bias of sgRNA repression

Plot the **weight of each sgRNA** to see if there is a dependency between correlation and sgRNA position. There is no significant trend.

```{r, fig.width = 3, fig.height = 3}
plot_sgRNA_correlation <- df_main %>%
  select(sgRNA_target, sgRNA_index, sgRNA_correlation) %>%
  filter(sgRNA_index <= 5) %>%
  distinct %>%
  # plot
  ggplot(aes(x = factor(sgRNA_index), y = sgRNA_correlation)) +
  geom_boxplot(outlier.shape = "") +
  labs(x = "sgRNA position", y = "correlation") +
  stat_summary(fun.data = function(x) c(y = median(x)+0.07, 
    label = round(median(x), 2)), geom = "text", size = 3) +
  stat_summary(fun.data = function(x) c(y = 1.1, 
    label = length(x)), geom = "text", color = grey(0.5), size = 3) +
  coord_cartesian(ylim = c(-0.15, 1.15)) +
  custom_theme()

save_plot(plot_sgRNA_correlation, width = 5, height = 4)
print(plot_sgRNA_correlation)
```

We can also quantify how many genes have strongly correlated sgRNAs and how many have outliers. In order to do this, the median weight of the (up to) 5 sgRNAs per gene is plotted. Generally, the median weight ranges between 0.5 and 1.0, showing on average good correlation.

```{r, fig.width = 3.5, fig.height = 3.3}
plot_sgRNA_correlation_hist <- df_main %>%
  select(sgRNA_target, sgRNA_index, sgRNA_correlation) %>%
  filter(sgRNA_index <= 5) %>%
  distinct %>% group_by(sgRNA_target) %>%
  summarize(
    median_sgRNA_correlation = median(sgRNA_correlation),
    min_sgRNA_correlation = min(sgRNA_correlation)
  ) %>%
  # plot
  ggplot(aes(x = median_sgRNA_correlation)) +
  geom_histogram(bins = 40, fill = custom_colors[1], alpha = 0.7) +
  custom_theme()

save_plot(plot_sgRNA_correlation_hist, width = 5, height = 4)
print(plot_sgRNA_correlation_hist)
```

Second, the binding position of the sgRNAs could be correlated to the strength of repression. In other words sgRNAs binding closer to the promoter could have stronger ability to repress a gene, see Figure 1 B in [Wang et al., Nature Comms, 2018](https://www.nature.com/articles/s41467-018-04899-x). We plot **sgRNA efficiency** for genes only, because the absolute majority of those has 5 sgRNAs.

```{r, fig.width = 3, fig.height = 3}
plot_sgRNA_efficiency <- df_main %>%
  filter(sgRNA_index <= 5, sgRNA_type == "gene") %>%
  select(sgRNA_target, sgRNA_index, sgRNA_efficiency) %>% distinct %>%
  ggplot(aes(x = factor(sgRNA_index), y = sgRNA_efficiency)) +
  geom_boxplot(notch = FALSE, outlier.shape = ".") +
  labs(x = "sgRNA position", y = "repression efficiency") +
  coord_cartesian(ylim = c(-0.15, 1.15)) +
  stat_summary(fun.data = function(x) c(y = median(x)+0.07, 
    label = round(median(x), 2)), geom = "text", size = 3) +
  stat_summary(fun.data = function(x) c(y = 1.1, 
    label = length(x)), geom = "text", color = grey(0.5), size = 3) +
  custom_theme()

save_plot(plot_sgRNA_efficiency, width = 5, height = 4)
print(plot_sgRNA_efficiency)
```

Export draft **Figure 1** for manuscript.

```{r, fig.width = 7, fig.height = 5.5}
plot_selected_sgRNAs <- df_main %>%
  filter(
    grepl("ctrl[1-5]$|rps10$", sgRNA_target), 
    condition %in% c("HC, HL", "HC, LL", "LC, IL", "LC, LL")) %>%
  mutate(
    sgRNA_index2 = as.numeric(str_extract(sgRNA_target, "[1-9]$")),
    sgRNA_index = case_when(sgRNA_position == 0 ~ sgRNA_index2, TRUE ~ sgRNA_index),
    sgRNA_target = str_extract(sgRNA_target, "[a-zA-Z]*")
  ) %>%
  ggplot(aes(x = time, y = log2FoldChange, color = factor(sgRNA_index))) +
  geom_line(size = 1) + geom_point(size = 2) +
  facet_grid(sgRNA_target ~ condition) +
  custom_theme(legend.position = 0) +
  coord_cartesian(ylim = c(-4.5, 2.5)) +
  scale_color_manual(values = custom_range(5))


svg(filename = "../figures/figure1.svg", width = 7, height = 5.5)
ggarrange(ncol = 2, widths = c(0.6, 0.4),
  ggarrange(plot_sgRNAs_per_gene, plot_selected_sgRNAs, nrow = 2, labels = c("A", "B"), font.label = list_fontpars),
  ggarrange(grid.rect(gp = gpar(col = NA)), plot_sgRNA_efficiency, grid.rect(gp = gpar(col = NA)), plot_sgRNA_correlation,
    nrow = 4, labels = c("C", "", "D", ""), font.label = list_fontpars, heights = c(0.04, 0.46, 0.04, 0.46))
)
dev.off()
```

Export **supplemental figure with all ribosomal genes** (rps*NN*/rpl*NN*).

```{r, fig.width = 7, fig.height = 10}
plot_sgRNAs_ribosome <- df_main %>%
  filter(str_detect(sgRNA_target, "rp[sl][0-9]*$")) %>%
  filter(condition == "HC, HL") %>%
  ggplot(aes(x = time, y = log2FoldChange, color = factor(sgRNA_index))) +
  geom_line(size = 1) + geom_point(size = 2) +
  facet_wrap(~ sgRNA_target, ncol = 7) +
  custom_theme(legend.position = "top") +
  scale_color_manual(values = custom_range(5))

print(plot_sgRNAs_ribosome)
save_plot(plot_sgRNAs_ribosome, width = 7, height = 10)
```


# Gene fitness calculation

## Summarize sgRNA fitness to gene fitness

With the correlation and the efficiency per sgRNA, we can compute the **weighted mean of all sgRNAs**. For comparison, we also test simple strategies such as the standard **arithmetic mean** and a top 1 and top 2 sgRNAs strategy. Metrics are calculated for log2 FC, and fitness.

```{r, warning = FALSE, message = FALSE}
df_gene <- df_main %>%
  
  # keep all annotation columns
  group_by(sgRNA_target, sgRNA_type, locus, gene_name, condition, 
    carbon, light, treatment, time) %>%
  
  # summarize FC and fitness...
  summarize(.groups = "drop",
    # log2 FC
    mean_log2FoldChange = mean(log2FoldChange),
    wmean_log2FoldChange = weighted.mean(log2FoldChange, sgRNA_correlation * sgRNA_efficiency),
    top1_log2FoldChange = log2FoldChange[which.max(sgRNA_efficiency)],
    top2_log2FoldChange = mean(log2FoldChange[order(sgRNA_efficiency, decreasing = TRUE)[1:2]]),
    sd_log2FoldChange = sd(log2FoldChange),
    # fitness
    mean_fitness = mean(fitness),
    wmean_fitness = weighted.mean(fitness, sgRNA_correlation * sgRNA_efficiency),
    top1_fitness = fitness[which.max(sgRNA_efficiency)],
    top2_fitness = mean(fitness[order(sgRNA_efficiency, decreasing = TRUE)[1:2]]),
    sd_fitness = sd(fitness)
  )
```

A comparison of log2 FC aggregated by the different method shows clear differences. For the example gene `rps10` the weighted mean and the top method give similar results, representative of the stronger influence from highly depleted sgRNA repression strains. The regular mean is robust, but "shallow", probably underestimating the real effect n fitness. The top 1 method simply picks the most depleted/enriched sgRNA (over all conditions) as representative.

```{r, fig.width = 7, fig.height = 5.5}
df_gene %>% filter(sgRNA_target == "rps10") %>%
  pivot_longer(cols = matches("[n12]_log2FoldChange"), 
    names_to = "metric", values_to = "log2FoldChange") %>%
  mutate(metric = str_remove(metric, "_log2FoldChange")) %>%
  ggplot(aes(x = time, y = log2FoldChange, 
    ymin = log2FoldChange-sd_log2FoldChange, 
    ymax = log2FoldChange+sd_log2FoldChange, color = fct_inorder(metric))) +
  geom_line(size = 1) + geom_point(size = 2) + geom_linerange(size = 1) +
  facet_wrap(~ condition, ncol = 4) +
  custom_theme(legend.position = "right") +
  coord_cartesian(ylim = c(-3.75, 0.75)) +
  scale_color_manual(values = custom_colors)
```


This plot shows a comparison of the 4 methods for the first 36 genes by alphabetical order, for one selected condition only (1% CO2, BG11, 1,000 µmol photons m-1 s-1). Here we can see that the top1 method is often but not always representative for the gene: For apcD or apcF, it does not seem representative compared to the mean, weighted mean, and top2 methods.

```{r, fig.width = 9, fig.height = 9}
df_gene %>% filter(
    gene_name %in% unique(.data[["gene_name"]])[1:36],
    condition == "HC, HL"
  ) %>%
  pivot_longer(cols = matches("[n12]_log2FoldChange"), names_to = "metric", values_to = "log2FoldChange") %>%
  mutate(metric = str_remove(metric, "_log2FoldChange")) %>%
  ggplot(aes(x = time, y = log2FoldChange, 
    ymin = log2FoldChange-sd_log2FoldChange,
    ymax = log2FoldChange+sd_log2FoldChange, color = fct_inorder(metric))) +
  geom_line(size = 1) + geom_point(size = 2) + geom_linerange(size = 1) +
  facet_wrap(~ sgRNA_target, ncol = 7) +
  custom_theme(legend.position = "top") +
  coord_cartesian(ylim = c(-5, 5)) +
  scale_color_manual(values = custom_colors)
```

## Global distribution of gene fitness

Global distribution of weighted mean fitness for all genes. Effect of ncRNA repression seems to be much lower than effect of gene repression.

```{r, fig.width = 7, fig.height = 5}
plot_all_fitness_hist <- df_gene %>% filter(time == 0) %>%
  ggplot(aes(x = wmean_fitness, fill = sgRNA_type)) +
  geom_histogram(bins = 100) +
  coord_cartesian(xlim = c(-4, 4), ylim = c(0, 1000)) +
  facet_wrap( ~ condition, ncol = 4) +
  custom_theme() +
  scale_fill_manual(values = custom_colors[3:4])

print(plot_all_fitness_hist)
save_plot(plot_all_fitness_hist, width = 7, height = 5)
```


## Behavior of control sgRNAs

Ten sgRNAs were included in the library that have no gene-specific targets. The following plot shows that these negative controls do not have an effect on strain fitness, except probably 2 sgRNAs in one specific condition.

```{r, fig.width = 7, fig.height = 5.5}
plot_controls_sgRNAs <- df_main %>% filter(grepl("ctrl", sgRNA_target)) %>%
  ggplot(aes(x = time, y = log2FoldChange, color = sgRNA_target)) +
  geom_line(size = 1) + geom_point(size = 2) + ylim(-5, 5) +
  facet_wrap(~ condition, ncol = 4) +
  custom_theme() +
  scale_color_manual(values = rep_along(1:10, custom_colors))

print(plot_controls_sgRNAs)
save_plot(plot_controls_sgRNAs, width = 7, height = 5.5)
```

# Unsupervised clustering of genes

## Cluster genes by similarity

```{r, fig.width = 8, fig.height = 5}
# generate color palette for heatmap
heat_cols <- colorspace::diverging_hcl(n = 7, h = c(255, 12), c = c(50, 80), l = c(20, 97), power = c(1, 1.3))

# create a matrix-like df with wide fitness data for plotting heatmap
df_heatmap <- df_gene %>%
  filter(time == 0, !is.na(locus)) %>%
  select(locus, condition, wmean_fitness) %>%
  mutate(wmean_fitness = wmean_fitness %>% replace(., . > 8, 8) %>% replace(., . < -8, -8)) %>%
  pivot_wider(names_from = condition, values_from = wmean_fitness) %>%
  column_to_rownames(var = "locus")

# subset of df with *strongly changed* genes
df_heatmap2 <- df_heatmap %>%
  filter(if_any(.cols = matches("[HL]C, "), ~ !between(., -4, 4)))

# create cluster for reordering
mat_cluster <- df_heatmap %>% as.matrix %>% dist %>% hclust(method = "ward.D2")
mat_heatmap <- df_heatmap %>% as.matrix %>%
  .[order.dendrogram(as.dendrogram(mat_cluster)), ncol(.):1]

# repeat this step with subset of *significantly changed* genes
mat_cluster_sig <- df_heatmap2 %>% as.matrix %>% dist %>% hclust(method = "ward.D2")
mat_heatmap_sig <- df_heatmap2 %>% as.matrix %>%
  .[order.dendrogram(as.dendrogram(mat_cluster_sig)), ncol(.):1]
```


Now we can plot _all_ genes, a subset with _only significant genes_, and a dendrogram for clustering. The result is hard to interpret. With some exceptions, most genes are grouped in broad unspecific clusters that do not reveal clear relationships between treatment variables and fitness outcome.
 
```{r, fig.width = 8, fig.height = 2.5}
plot_heatmap_all <- levelplot(mat_heatmap,
  par.settings = custom.colorblind(),
  col.regions = colorRampPalette(heat_cols)(20),
  at = seq(-8, 8, 1), aspect = "fill",
  xlab = paste0("genes (", nrow(mat_heatmap),")"),
  ylab = "", scales = list(x = list(draw = FALSE)),
  panel = function(x, y, z, ...) {
    panel.levelplot(x, y, z, ...)
    panel.abline(h = 1:5+0.5, col = "white", lwd = 1.5)
  }
)

print(plot_heatmap_all)
save_plot(plot_heatmap_all, width = 8, height = 2.5)
```

```{r, fig.width = 8, fig.height = 4}
plot_heatmap_sig <- levelplot(mat_heatmap_sig,
  par.settings = custom.colorblind(),
  col.regions = colorRampPalette(heat_cols)(20),
  at = seq(-8, 8, 1), aspect = "fill",
  xlab = paste0("genes (", nrow(mat_heatmap_sig),")"),
  ylab = "", scales = list(x = list(draw = FALSE)),
  panel = function(x, y, z, ...) {
    panel.levelplot(x, y, z, ...)
    panel.abline(h = 1:ncol(mat_heatmap_sig)+0.5, col = "white", lwd = 1.5)
  }
)

plot_cluster_dend <- mat_cluster_sig %>% as.dendrogram %>%
  set("branches_k_col", custom_colors[1:5], k = 5) %>%
  set("branches_lwd", 0.5) %>%
  as.ggdend %>%
  ggplot(labels = FALSE)

gridExtra::grid.arrange(
  # coords for unit: top, right, bottom, left
  plot_cluster_dend + 
    theme(plot.margin = unit(c(0.1, 0.075, -0.26, 0.135),"npc")),
  plot_heatmap_sig,
  nrow = 2
)
```

```{r, include = FALSE}
png("../figures/plot_heatmap_signif.png", width = 1600, height = 800, res = 200)
gridExtra::grid.arrange(
  # coords for unit: top, right, bottom, left
  plot_cluster_dend + 
    theme(plot.margin = unit(c(0.1, 0.08, -0.25, 0.14),"npc")),
  plot_heatmap_sig,
  nrow = 2
)
invisible(capture.output(dev.off()))
```


## Gene similarity by dimensionality reduction methods

We use two different dimensionality reduction methods, **nMDS** and **t-SNE**. We can check if these methods reproduce the clustering for the significantly regulated genes produced with `hclust`. Analysis shows that the small clusters are more strongly separated from the rest.

```{r, fig.width = 8, fig.height = 4}
# set a seed to obtain same pattern for stochastic methods
set.seed(123)

# run nMDS analysis
NMDS <- df_heatmap2 %>% as.matrix %>% dist %>% metaMDS
df_nmds <- NMDS$points %>% as_tibble(rownames = "locus") %>%
  left_join(enframe(cutreeord(mat_cluster_sig, k = 5), "locus", "cluster"))

# run t-SNE analysis
SNE <- tsne::tsne(df_heatmap2 %>% as.matrix %>% dist)
df_tsne <- SNE %>% setNames(c("x", "y")) %>% as_tibble %>%
  mutate(locus = rownames(df_heatmap2)) %>%
  left_join(enframe(cutreeord(mat_cluster_sig, k = 5), "locus", "cluster"))

plot_nmds <- df_nmds %>% 
  ggplot(aes(x = MDS1, y = MDS2, color = factor(cluster))) +
  geom_point(size = 2) + labs(title = "nMDS") +
  custom_theme(legend.position = c(0.85, 0.78)) +
  scale_color_manual(values = custom_colors)

plot_tsne <- df_tsne %>% 
  ggplot(aes(x = V1, y = V2, color = factor(cluster))) +
  geom_point(size = 2) + labs(title = "t-SNE") +
  custom_theme(legend.position = c(0.85, 0.78)) +
  scale_color_manual(values = custom_colors)

gridExtra::grid.arrange(plot_nmds, plot_tsne, ncol = 2)
ggsave("../figures/plot_nmds_tsne.svg",
  plot = gridExtra::arrangeGrob(plot_nmds, plot_tsne, ncol = 2),
  device = "svg", width = 8, height = 4)
```

## Fit multiple linear regression models

We can find clusters of genes with similar fitness, but it is also important to identify _why_ they cluster together. In order to find out _which variables_ determine the fitness outcome of a gene, we can perform **multiple linear regression**. Each gene needs to have fitness outcomes annotated with the different (mixed) variables `carbon`, `light`, `treatment`. The latter can be subdivided in individual treatment columns glucose, DCMU, fluctuating light, and so on. Multiple linear regression fits a linear model of the following form to the data:

`response ~ intercept + predictor A x slope A + predictor B x slope B x ...`

Here, `fitness` is the response variable, the different conditions are the predictors. It is important to convert the categorical predictors into (numerical) dummy variables. Then for each individual gene, multiple linear models are fitted and the power of each predictor variable to predict the response is extracted.

```{r}
# fixed model with 6 predictor variables -- dynamic layout would 
# be better in future
fit_linreg <- function(y, x1, x2, x3, x4, x5, x6){
  fit <- lm(y ~ x1 + x2 + x3 + x4 + x5 + x6)
  c(coefficients(fit), summary(fit)$coefficients[, 4],
    summary(fit)$r.squared)
}

# recode categorical to numerical (dummy) variables
df_linreg <- df_gene %>%
  filter(!is.na(locus)) %>%
  select(locus, carbon, light, treatment, wmean_fitness) %>% distinct %>%
  mutate(
    carbon = recode(carbon, `HC` = 1, `LC` = 0),
    light = recode(light, `LL` = 0, `IL` = 0.5, `HL` = 1)) %>%
  mutate(dummy = 1, treatment = replace(treatment, treatment == "", "-")) %>%
  pivot_wider(names_from = treatment, values_from = dummy, values_fill = 0) %>%
  mutate(`+G` = `+G` + `+D, +G`) %>% rename(`+D` = `+D, +G`) %>% select(-`-`) %>%
  # fit model
  group_by(locus) %>%
  summarize(coefficient = fit_linreg(wmean_fitness, carbon, light, `-N`, `+FL`, `+G`, `+D`),
    .groups = "keep") %>% #unnest(coefficient) %>%
  mutate(treatment = c(rep(c("intercept", "carbon", "light", "-N", "+FL", "+G", "+D"), 2) %>% 
    paste0(rep(c("", "pval_"), each = 7), .), "r_squared"))
```

Now we can overlay the information of the best predictor variable on the cluster map produced by tSNE, for example, and this way identify groups of genes regulated in a similar degree, by similar variables.

```{r, fig.width = 9, fig.height = 12}
plot_tsne_linreg <- df_tsne %>%
  inner_join(df_linreg, by = "locus") %>%
  left_join(select(df_gene, locus, sgRNA_target) %>% distinct, by = "locus") %>%
  filter(!str_detect(treatment, "intercept|pval|r_squared")) %>%
  mutate(sgRNA_target = if_else(abs(coefficient) > 2, sgRNA_target, "")) %>%
  mutate(point_size = abs(coefficient),
    coefficient = coefficient %>% replace(., . > 5, 5) %>% replace(., . < -5, -5)) %>%
  
  ggplot(aes(x = V1, y = V2, size = point_size,
    color = coefficient, label = sgRNA_target)) +
  geom_point() +
  labs(title = "t-SNE clustering of DF genes", 
    subtitle = paste0("dot color/size encodes effect of variable, n = ", nrow(df_tsne))) +
  custom_theme(aspect = 1) +
  scale_color_gradientn(limits = c(-5, 5),
    colours = c(custom_colors[1], grey(0.6, 0.8), custom_colors[2])) +
  scale_size_continuous(range = c(0.5, 7)) +
  geom_text_repel(size = 3, max.overlaps = 50) +
  facet_wrap( ~ treatment, ncol = 2)

print(plot_tsne_linreg)
```

This strategy reveals a list of interesting condition-specific genes:

- Nitrogen limitation: `ssr3532` - unknown short protein, strongest known interaction in STRING with GlsA glutaminase
- Fluctuating light:
  - `sll1521` - Putative diflavin flavoprotein A3 (dfa3), negatively corr. with fitness
  - `sll0217` Putative diflavin flavoprotein A2 (dfa2), positively corr. with fitness
- Mixotrophy:
  - `sll0593` - glk, glucokinase, catalyzes P-ylation of Glc to G6P
  - `sll1533` - pilT, fimbria assembly, mobility, Glc transport or sensing?
  - `ssl3364` - unknown short protein, strongly interacts with RbcX, RbcR, Prk. Important for C-metabolism adapation?
- Light:
  - `ssr2142` ycf19, short unknown protein, interacts with psbO and Tat membrane protein insertion system,
  - `slr0963` sir, sulfite reductase, ferredoxin H2O + HS + ferredoxin <-> H+ + reduced ferredoxin + sulfite,
    strongly interacts with other proteins in sulfur metabolism, specifically related to cofactor biosynthesis, 
    cobalamin (vitamin B12) and    siroheme
- Light, mixotrophy, heterotrophy: cluster of photosynthesis related genes increase fitness when KOed: apcA,D,E, psbB,C,D
- Carbon:
  - `sll0217` Putative diflavin flavoprotein A2 (dfa2), KO negatively correlated with fitness with C, positive with +FL
  - `sll0218` same behavior as dfa2, interacts with dfa2,4, contributes to PSII stabilization, 
     [Bersanini et al., 2017](https://pubmed.ncbi.nlm.nih.gov/27928824/)

## List of genes with strong fitness correlation

The table with linear regression coefficients and p-values is reshaped to long format for better readability. The `kableExtra` package is used to color cells for easier recognition. Then we subset the table for each treatment in order to spot the most interesting genes.

```{r}
df_linreg_wide <- df_linreg %>%
  pivot_wider(names_from = treatment, values_from = coefficient) %>%
  left_join(select(df_gene, locus, sgRNA_target) %>% distinct, by = "locus") %>%
  select(-matches("intercept")) %>%
  filter(if_any(matches("^(carb|light|\\-|\\+)"), ~ abs(.) > 2)) %>%
  mutate(across(matches("carb|light|\\-|\\+"), ~ round(., 3))) %>% 
  ungroup %>% select(sgRNA_target, locus, matches("."))

color_table <- function(df, variable) {
  filter(df, abs(.data[[variable]]) > 2) %>% 
  select(matches("^(sg|loc|r_s|carb|light|\\-|\\+)") | all_of(paste0("pval_", variable))) %>%
  arrange(desc(.data[[variable]])) %>%
  mutate(across(3:8, ~ cell_spec(., "html", color = "white",
      background = spec_color(., option = "E", scale = c(-5.5, 5.5)),
      bold = TRUE))) %>%
  kbl(format = "html", escape = F) %>%
  kable_paper("striped", full_width = F)
}
```


```{r}
df_linreg_wide %>% color_table("carbon")
```

```{r}
df_linreg_wide %>% color_table("light")
```

```{r}
df_linreg_wide %>% color_table("-N")
```

```{r}
df_linreg_wide %>% color_table("+FL")
```

```{r}
df_linreg_wide %>% color_table("+G")
```

```{r}
df_linreg_wide %>% color_table("+D")
```
Based on the multiple linear model correlations, we can try to extract a shortlist of the most interesting **hypothetical genes**. These could warrant further investigations.

```{r}
list_top_unknown_hits <- df_linreg_wide %>%
  left_join(df_uniprot, by = "locus") %>%
  # filter by name: only unknown proteins
  filter(
    is.na(gene_name_short),
    str_detect(protein, "[a-zA-Z]{3}[0-9]{4} protein|Uncharacterized")) %>%
  # filter by effect: only correlation > 3
  filter(if_any(matches("^(carb|light|\\-|\\+)"), ~ abs(.) > 3)) %>%
  arrange(desc(r_squared)) %>%
  pull(locus)

df_linreg_wide %>% filter(locus %in% list_top_unknown_hits) %>%
  select(!starts_with("pval"), -sgRNA_target) %>%
  mutate(across(2:7, ~ cell_spec(., "html", color = "white",
      background = spec_color(., option = "E", scale = c(-5.5, 5.5)),
      bold = TRUE))) %>%
  kbl(format = "html", escape = F) %>%
  kable_paper("striped", full_width = F)
```


## Extract and analyze interesting gene clusters

The list above shows the genes whose fitness is most significantly correlated with one of the treatments.
This list of genes is extracted and then simply fitness per condition is plotted as a heatmap, in order to confirm the trends from fitting the multiple liner regression models.


```{r, fig.width = 4.5, fig.height = 3.5}
library(ggheatmap)

plot_sgRNAs_light <- df_gene %>%
  
  # make df with list of strongest correlated genes
  filter(locus %in% list_top_unknown_hits) %>%
  
  # reshape to wide format
  mutate(wmean_fitness = wmean_fitness %>% replace(., . > 3.5, 3.5) %>% replace(., . < -3.5, -3.5)) %>%
  filter(time == 0) %>% select(sgRNA_target, condition, wmean_fitness) %>%
  pivot_wider(names_from = condition, values_from = wmean_fitness) %>%
  column_to_rownames("sgRNA_target") %>% t %>%
  
  # plot heatmap
  ggheatmap(cluster_rows = TRUE, cluster_cols = TRUE,
    color = brewer_pal(direction = -1, palette = "RdBu")(5),
    show_cluster_rows	= FALSE, cluster_num = c(1,1),
    tree_color_cols = grey(0.5),
  ) %>% ggheatmap_theme(plotlist = 1, theme = list(
    custom_theme() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5), 
      axis.title.x = element_blank(), axis.title.y = element_blank())
  ))

print(plot_sgRNAs_light)
save_plot(plot_sgRNAs_light, width = 8.0, height = 3.5)
```
**Summary**

- `sll0364` - 139 AA. KD has higher fitness in HC conditions and lower fitness in HL. Negatively regulating carbon metabolism?
- `sll0481` - 155 AA. KD has higher fitness in +G conditions and lower fitness in HL. Membrane localization. Negatively regulating glycolysis?
- `sll0877` - 456 AA. KD has higher fitness _only_ in HC,LL. Mitigates light limitation?
- `ssl3364` -  74 AA. KD has lower fitness on all HC/+G conditions. This protein is known as CP12 protein, regulating glycolytic flux at GAPDH and PRK.
- `ssr3532` -  80 AA. KD lower fitness on N-limitation and C-limitation (LC-HL combinations). Same operon as glutaminase glsA (slr2079, catalyzes deamination of gln --> glu), regulatory, involved in N metabolism?
- `slr1990` - 240 AA, 5 TM domains. KD higher fitness in photoheterotrophy, lower fitness in all HC/LL conditions. Something important for photosystems? Something that wastes e- in photoheterotrophic conditions?
- `sll6055` - 152 AA. Fitness profile as above. Multiubiquitin domain, involved in protein modification/degradation of PS proteins?
- `slr1505` - 198 AA. Fitness profile as above. No useful information.
- `sll1378` - 300 AA.  KD has lower fitness on all LL conditions. Membrane associated protein? In STRING, potential interaction with PbsA1 and PbsA2 (Heme oxygenase 1 and 2). Potentially important for chlorophyll or heme biosynthesis --> would explain importance for photosynthesis in LL condition.
- `slr1102` - 853 AA. KD has lower fitness on all LL conditions. 4 known domains, FHA (forkhead-associated domain is a phosphopeptide recognition domain found in many regulatory proteins), PAS (signaling, often involved in circadian proteins, detect their signal by way of an associated cofactor like heme, flavin), GGDEF (involved in signal transduction, likely to catalyze synthesis or hydrolysis of cyclic diguanylate c-diGMP), EAL (shown to stimulate degradation of a second messenger, cyclic di-GMP, candidate for a diguanylate phosphodiesterase function. Together with the GGDEF domain, EAL might be involved in regulating cell surface adhesiveness in bacteria). Source: InterPro. Embedded in a [tight network](https://string-db.org/network/1148.1651834) of interacting proteins all involved in chromophore biosynthesis/maturation.

**Apc and cpc repression mutants** encoding phycobilisomes are also enriched in high light


```{r, fig.width = 6.5, fig.height = 3.5}
plot_sgRNAs_phycobil <- df_gene %>%
  filter(str_detect(gene_name, "[ac]pc"), time == 0) %>%
  mutate(wmean_fitness = wmean_fitness %>% replace(., . > 4, 4) %>% replace(., . < -4, -4)) %>%
  ggplot(aes(x = sgRNA_target, y = condition, fill = wmean_fitness)) +
  geom_tile() + custom_theme() +
  labs(title = "Apc/Cpc mutants enriched in high light/CO2", x = "", y = "") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_fill_distiller(palette = "RdBu", limits = c(-4, 4))

print(plot_sgRNAs_phycobil)
save_plot(plot_sgRNAs_phycobil, width = 6.5, height = 3.5)
```

## Interaction analysis using STRING database

The next step is to retrieve additional information about these clusters to find correlated genes, groups, pathways, or regulatory networks. We can use the STRING database for this task.

```{r, echo = FALSE}
suppressPackageStartupMessages({
  library(ggraph)
  library(tidygraph)
})

# function to retrieve network interaction data from STRING DB
# separate gene IDs by "%0d"; species/taxon ID for Synechocystis sp. PCC 6803: 1148
# (see https://string-db.org/cgi/organisms)
plot_STRING <- function(gene_ID, taxon_ID, 
  min_score = 0000, ref = NULL, plot = TRUE, groups = NULL
) {
  gene_list <- paste(gene_ID, collapse = "%0d")
  string_graph <- paste0(
    "https://string-db.org/api/tsv/network?identifiers=", 
    gene_list, "&species=", taxon_ID, "&required_score=", min_score) %>%
    read_tsv(col_types = cols()) %>%
    select(-stringId_A, -stringId_B) %>%
    as_tbl_graph()
  if (!is.null(ref)) {
    # add gene annotation
    string_graph <- left_join(string_graph, ref, by = "name")
  }
  if (plot) {
    # function to space labels in certain distance to circle
    nudge_circle <- function(n, size_x = 0.2, size_y = 0.15) {
      nudge_x = size_x * -cos(seq(0.5*pi, 2.5*pi, length.out = n))
      nudge_y = size_y * sin(seq(0.5*pi, 2.5*pi, length.out = n))
      list(x = nudge_x, y = nudge_y)
    }
    # plot using ggraph
    n_nodes <- string_graph %>% activate(nodes) %>% pull(name) %>% length
    string_graph %>% arrange(across(matches(groups))) %>% activate(edges) %>%
      filter(score >= 0.4) %>%
      ggraph(layout = 'linear', circular = TRUE) +
      geom_edge_arc(colour = grey(0.6, 0.5), aes(width = score)) + 
      geom_node_point(aes(colour = .data[[groups]]), size = 4) +
      geom_node_text(nudge_x = nudge_circle(n_nodes)$x, 
        nudge_y = nudge_circle(n_nodes)$y,
        size = 3, aes(label = name, colour = .data[[groups]])) +
      scale_edge_width(range = c(0.2, 2)) +
      theme_graph(background = "white", foreground = grey(0.5),
        plot_margin = margin(10, 10, 10, 10))
  }
}
```


```{r, fig.width = 5.5, fig.height = 4.0}
list_corr_genes <- df_linreg_wide %>%
  filter(if_any(matches("^(carb|light|\\-|\\+)"), ~ abs(.) >= 3 )) %>%
  filter(if_any(matches("^pval_"), ~ abs(.) <= 0.05 )) %>% pull(locus)
  
plot_STRING(
  gene_ID = list_corr_genes,
  taxon_ID = 1148,
  ref = df_gene %>% select(sgRNA_target, locus, gene_name) %>% 
    distinct %>% rename(name = sgRNA_target),
  groups = "name"
)
```

# Direct comparison of gene fitness

## Fitness of all conditions vs each other

We can plot selected conditions against each other and add gene labels in order to find or confirm particular patterns.

```{r}
make_fitness_plot <- function(data, vars, title = NULL) {
  # prepare data for two  variables each
  data %>% ungroup %>%
    filter(condition %in% vars, sgRNA_type == "gene") %>%
    select(locus, sgRNA_target, condition, wmean_fitness) %>% distinct %>%
    pivot_wider(names_from = condition, values_from = wmean_fitness) %>%
    mutate(
      dfit = get(vars[1]) - get(vars[2]),
      significant = !between(dfit, quantile(dfit, probs = c(0.003)),
        quantile(dfit, probs = c(0.997))),
      sgRNA_target = if_else(significant, sgRNA_target, "")) %>%
    
    # plot
    ggplot(aes(x = get(vars[1]), y = get(vars[2]), 
      color = significant, label = sgRNA_target)) +
    geom_point(size = 1) + custom_theme(legend.position = 0) +
    geom_abline(intercept = 0, slope = 1, col = grey(0.5), lty = 2, size = 0.8) +
    geom_abline(intercept = 4, slope = 1, col = grey(0.5), lty = 2, size = 0.8) +
    geom_abline(intercept = -4, slope = 1, col = grey(0.5), lty = 2, size = 0.8) +
    geom_text_repel(size = 3, max.overlaps = 50) +
    labs(title = title, x = vars[1], y = vars[2]) +
    coord_cartesian(xlim = c(-9, 5), ylim = c(-9, 5)) +
    scale_color_manual(values = c(grey(0.5), custom_colors[2]))
}

# browse through all possible condition combinations;
# we need a helper function that detects duplicated combinations
duplicated_2vec <- function(x, y) {
  xy = paste(x, y); yx = paste(y, x)
  sapply(xy, function(xval) {
    which(xval == yx) <= which(xval == xy)
  })
}

list_condition_pairs <- lapply(
  unique(df_gene$condition) %>% expand_grid(x = ., y = .) %>%
    filter(!duplicated_2vec(x, y)) %>% t %>% as.data.frame %>% as.list,
  function(var) {
    make_fitness_plot(df_gene, vars = var,
      title = paste(var, collapse = "  -  "))
  }
)

# export images
invisible(capture.output(
  lapply(list_condition_pairs, function(pl) {
    pl_name <- paste0("../figures/pairwise_comparisons/plot_", pl$labels$x, "_", pl$labels$y, ".png")
    png(filename = pl_name, width = 800, height = 800, res = 120)
    print(pl)
    dev.off()
  })
))
```

```{r, include = FALSE, eval = FALSE}
# # Code chunk to perform t-test on summary statistics
# # -------------------
# library(BSDA)
#   mutate(t_test = tsum.test(
#   mean.x = get(paste0("wmean_fitness_", vars[1])),
#   s.x = get(paste0("sd_fitness_", vars[1])), n.x = 5, 
#   mean.y = get(paste0("wmean_fitness_", vars[2])), 
#   s.y = get(paste0("sd_fitness_", vars[2])), n.y = 5)$p.value) %>%
#   mutate(significant = t_test <= 0.05) %>%
```



```{r, fig.width = 5, fig.height = 5}
# example of first 4 combinations
list_condition_pairs[1:4]
```

# Differential fitness of selected gene sets

## Central carbon metabolism

To plot gene fitness for the enzymes of central carbon metabolism, we need a complete list of enzymes and the genes that they are mapped to. To list the different **KEGG databases** that can be queried, use `listDatabases()`. Gene-pathway mappings are obtained and merged with pathway names and gene/enzyme names.

```{r}
# get mapping of pathways for each gene
df_kegg <- keggLink("pathway", "syn") %>%
  enframe(name = "locus", value = "kegg_pathway_id") %>%
  
  # get list of pathways with name/ID pairs
  left_join(by = "kegg_pathway_id",
    keggList("pathway", "syn") %>%
    enframe(name = "kegg_pathway_id", value = "kegg_pathway")
  ) %>%
  
  # get list of gene/enzyme names
  left_join(by = "locus",
    keggList("syn") %>%
    enframe(name = "locus", value = "kegg_gene") %>%
    mutate(kegg_gene_short = str_extract(kegg_gene, "^[a-zA-Z0-9]*;") %>% 
      str_remove(";"))
  ) %>%
  
  # trim useless prefixes
  mutate(
    locus = str_remove(locus, "syn:"),
    kegg_pathway_id = str_remove(kegg_pathway_id, "path:"),
    kegg_pathway = str_remove(kegg_pathway, " - Synechocystis sp. PCC 6803")
  )

head(df_kegg)
```

Then we can extract gene sets for specific pathways and plot fitness. We start with glycolysis and Calvin cycle enzymes.

```{r}
list_central_met_pathways <- c(
  "Glycolysis / Gluconeogenesis",
  "Pentose phosphate pathway",
  "Carbon fixation in photosynthetic organisms",
  "Photosynthesis",
  "Photosynthesis - antenna proteins",
  "Citrate cycle (TCA cycle)",
  "Pyruvate metabolism",
  "Glyoxylate and dicarboxylate metabolism"
)
```


```{r}
plot_gene_fitness <- function(df, pw = NULL, gene = NULL, title = NULL) {
  df <- df %>% filter(time == 0)
  if (!is.null(pw)) {
    df <- df %>% inner_join(df_kegg %>% filter(kegg_pathway == pw) %>% select(locus),
      by = "locus")
    title <- pw
  } else if (!is.null(gene)) {
    df <- df %>% filter(locus %in% gene)
  }
  
  ggplot(df, aes(x = condition, y = wmean_fitness, 
    ymin = wmean_fitness-sd_fitness, 
    ymax = wmean_fitness+sd_fitness, fill = condition, color = condition)) +
    geom_col(position = "dodge", width = 0.6) +
    geom_errorbar(position = "dodge", width = 0.6, size = 1) +
    custom_theme(aspect.ratio = 1,
      legend.position = "bottom", legend.key.size = unit(0.4, "cm")) + 
    labs(title = title) +
    theme(axis.text.x = element_blank()) +
    scale_fill_manual(values = colorRampPalette(custom_colors[1:5])(11)) +
    scale_color_manual(values = colorRampPalette(custom_colors[1:5])(11)) +
    facet_wrap(~ sgRNA_target, ncol = 8)
}
```


```{r, fig.width = 8, fig.height = 6}
print(plot_gene_fitness(df_gene, pw = list_central_met_pathways[[1]]))
ggsave("../figures/plot_fitness_glycolysis.svg",
  plot_gene_fitness(df_gene, pw = list_central_met_pathways[[1]]),
  width = 8, height = 6)
```

```{r, fig.width = 8, fig.height = 5}
print(plot_gene_fitness(df_gene, pw = list_central_met_pathways[[2]]))
ggsave("../figures/plot_fitness_pentose.svg",
  plot_gene_fitness(df_gene, pw = list_central_met_pathways[[2]]),
  width = 8, height = 5)
```

```{r, fig.width = 8, fig.height = 5}
print(plot_gene_fitness(df_gene, pw = list_central_met_pathways[[3]]))
ggsave("../figures/plot_fitness_carbonfix.svg",
  plot_gene_fitness(df_gene, pw = list_central_met_pathways[[3]]),
  width = 8, height = 5)
```

```{r, fig.width = 8, fig.height = 11}
print(plot_gene_fitness(df_gene, pw = list_central_met_pathways[[4]]))
ggsave("../figures/plot_fitness_photosys.svg",
  plot_gene_fitness(df_gene, pw = list_central_met_pathways[[4]]),
  width = 8, height = 11)
```

```{r, fig.width = 8, fig.height = 4}
print(plot_gene_fitness(df_gene, pw = list_central_met_pathways[[5]]))
ggsave("../figures/plot_fitness_antenna.svg",
  plot_gene_fitness(df_gene, pw = list_central_met_pathways[[5]]),
  width = 8, height = 4)
```

```{r, fig.width = 8, fig.height = 4}
print(plot_gene_fitness(df_gene, pw = list_central_met_pathways[[6]]))
ggsave("../figures/plot_fitness_citrate.svg",
  plot_gene_fitness(df_gene, pw = list_central_met_pathways[[6]]),
  width = 8, height = 4)
```

**Custom set of stress related genes**

OCP (`slr1963`), pgr5 (`ssr2016`), Flv1 (`sll1521`), Flv2 (`sll0219`), Flv3 (`sll0550`), Flv4 (`sll0217`), `sll0218` (in flv2/4 operon), SigB (`sll0306`), SigC (`sll0184`), SigD (`sll2012`), SigE (`sll1689`).

```{r, fig.width = 8, fig.height = 4}
list_stress_genes <- c("slr1963", "ssr2016", "sll1521",
  "sll0219", "sll0550", "sll0217", "sll0218", "sll0306", "sll0184",
  "sll2012", "sll1689")

plot_gene_fitness(df_gene, gene = list_stress_genes, title = "stress related genes")
ggsave("../figures/plot_fitness_stress.svg",
  plot_gene_fitness(df_gene, gene = list_stress_genes, title = "stress related genes"),
  width = 8, height = 4)
```

**Fitness plot for carbon transports and carboxysome shell**

`slr1512` sbtA, `slr1513` sbtB, `sll1734` cupA, `slr1302` cupB, `sll0359` cyabrB1, `sll0822` cyabrB2,
`sll1594` ccmR, `sll1031` ccmM, `sll1028` ccmK2, `sll1029` ccmK1, `sll1032` ccmN, `slr0436` ccmO,
`sll1030` ccmL.

```{r, fig.width = 8, fig.height = 4}
list_carboxysome_genes <- c(
  "slr1512", "slr1513", "sll1734", "slr1302", "sll0359", "sll0822", "sll1594",
  "sll1031", "sll1028", "sll1029", "sll1032", "slr0436", "sll1030"
)

plot_gene_fitness(df_gene, gene = list_carboxysome_genes,
  title = "Carboxysome and carbon transporters")
ggsave("../figures/plot_fitness_carboxysome.svg",
  plot_gene_fitness(df_gene, gene = list_carboxysome_genes,
    title = "Carboxysome and carbon transporters"),
  width = 8, height = 4)
```

**Genes whose KD leads to increased fitness**


```{r, fig.width = 8, fig.height = 8}
list_genes_pos_fitness <- df_gene %>%
  filter(time == 0, !is.na(locus), wmean_fitness > 2) %>%
  pull(locus) %>% unique

plot_gene_fitness(df_gene, gene = list_genes_pos_fitness, title = "Genes with increased fitness (f > 2)")
ggsave("../figures/plot_fitness_increased.svg",
  plot_gene_fitness(df_gene, gene = list_genes_pos_fitness, title = "Genes with increased fitness (f > 2)"),
  width = 8, height = 8)
```

Summary:
- pmgA is once again the gene with strongest and most widespread fitness increase, validating results from library V1
- slr1916 same phenotype as pmgA just weaker. We also know this one from before. Must have identical role as pmgA.
- all PSII genes show increased fitness in photoheterotrophic condition --> PS is a burden here
- sll0689, pxcA, slr1609 - all increased fitness in HC,HL, first two are Na+/CO2 (?) trnasporters,
  slr1609 we know from before,   annotated as fatty acid CoA ligase, but probably it's something different
- sll6055, slr1505, slr1990 - all increased fitness in photoheterotrophic condition, and decreased fitness in HC/LL conditions.
  Not much is known about these genes, probably a role in photosynthesis, as the pattern is similar to psb genes (PSII maturation?)
- slr0813, slr0907, slr909, slr1299 - all increased fitness in HC/LL. Not clear what connects these genes functionally.

# Gene enrichment analysis

Sometimes even small effects in fitness can be relevant if several genes of the same pathway (or iso-enzymes) are affected. A simple fitness threshold will not reveal those changes. In such cases a more nuanced approach can be taken, a gene set enrichment analysis (GSEA). Several packages exist to test if functionally related genes are enriched, depleted, or both at the same time / the same conditions.

Before we test for enrichment of associated pathways/GO terms, we can have a look at the general depletion/enrichment per KEGG pathway. The fitness distribution per pathway can be visualized using a violin- or scatter plot.

```{r, fig.width = 10, fig.height = 15}
df_gene %>% filter(time == 0) %>%
  inner_join(df_kegg, by = "locus") %>%
  group_by(kegg_pathway, condition) %>%
  filter(length(unique(locus)) > 10) %>%
  
  ggplot(aes(x = condition, y = wmean_fitness,
      fill = condition, color = condition)) +
    geom_abline(intercept = 0, slope = 0, lty = 2, color = grey(0.5)) +
    geom_violin(color = "white") +
    stat_summary(fun.data = mean_sdl, geom = "pointrange", size = 0.4) +
    custom_theme(aspect.ratio = 1,
      legend.position = "bottom", 
      legend.key.size = unit(0.4, "cm")) +
    theme(axis.text.x = element_blank()) +
    facet_wrap(~ str_sub(kegg_pathway, 1, 16), ncol = 7) +
    coord_cartesian(ylim = c(-3.5, 3.5)) +
    scale_fill_manual(values = alpha(colorRampPalette(custom_colors[1:5])(11), 0.5)) +
    scale_color_manual(values = colorRampPalette(custom_colors[1:5])(11))
```

## KEGG pathway enrichment

We use the functions `kegga` for KEGG enrichment analysis and `goana` for GO term enrichment from the `limma` package. Both functions test for over or under-representation of genes associated with certain pathways or GO terms. The functions don't take the strength of differential fitness into account (DF; the depletion/enrichment over time).


```{r}
df_kegg_enrichment <- lapply(unique(df_gene$condition), function(cond) {
  df_gene %>% filter(
  sgRNA_type == "gene", time == 0,
  condition == cond) %>%
  
  # filter for differential fitness (DF) genes
  filter(!between(wmean_fitness, -1.0, 1.0), !is.na(locus)) %>%
  
  # perform KEGG enrichment
  pull(locus) %>% kegga(species.KEGG = "syn") %>%
  mutate(condition = cond)
}) %>% bind_rows

head(df_kegg_enrichment)
```

Now we visualize the pathways that are most enriched for DF genes. It turns out that ribosomal proteins are extremely depleted and therefore score high on the negative log10 p-value for pathway enrichment.

```{r}
df_kegg_enrichment %>%
  group_by(Pathway) %>% filter(any(P.DE <= 0.01)) %>%
  select(Pathway, condition, P.DE) %>%
  mutate(log10_p_value = -log10(P.DE), .keep = "unused") %>%
  
  # format some columns
  mutate(condition = str_replace(condition, pattern = "0.05% CO2", replacement = "LC") %>%
    str_replace(pattern = "1% CO2", replacement = "HC") %>%
    str_replace(pattern = "60uE", replacement = "LL") %>%
    str_replace(pattern = "1000uE", replacement = "HL")) %>%
  mutate(Pathway = str_sub(Pathway, 1, 25)) %>%
  # optionally remove ribosomes
  # filter(Pathway != "Ribosome") %>%
  
  # make correlation plot
  pivot_wider(names_from = condition, values_from = log10_p_value) %>%
  column_to_rownames(var = "Pathway") %>% as.matrix %>% t %>%
  corrplot(is.corr = FALSE, tl.col = grey(0.5), tl.cex = 0.8,
    col = colorRampPalette(custom_colors[c(1,5,2)])(10), col.lim = c(0, 20))
```


# Export summary table of all genes and conditions

Export a summary table of all genes and conditions, so that it's easy for other people to look up single conditions as for example done in [one-by-one fitness comparisons](#fitness-of-all-conditions-vs-each-other). This is best done in wide format (one column per condition).

```{r}
df_gene %>% ungroup %>%
  filter(sgRNA_type == "gene") %>%
  select(locus, sgRNA_target, gene_name, condition, wmean_fitness) %>% 
  distinct %>%
  pivot_wider(names_from = condition, values_from = wmean_fitness) %>%
  write_csv("../data/output/fitness_summary.csv")

df_gene %>%
  filter(sgRNA_type == "gene") %>%
  write_csv("../data/output/fitness_genes.csv")

df_kegg %>% write_csv("../data/output/kegg_annotation.csv")
```


# Session Info

```{r}
sessionInfo()
```

