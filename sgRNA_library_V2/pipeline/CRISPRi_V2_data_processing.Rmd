---
title: "CRISPRi library V2, data processing pipeline"
output:
  html_notebook: 
    theme: cosmo
    toc: yes
    number_sections: true
---

----------

# Description

This R notebook details the data processing and visualization for growth competition experiments with a CRISPRi sgRNA library. The library contains around 20,000 unique sgRNA repression mutants tailored for the cyanobacterium _Synechocystis_ sp. PCC6803. This library is the second version (therefore "V2") of an sgRNA library for _Synechocystis_, containing 5 instead of only 2 sgRNAs per gene if possible. Some genes or ncRNAs are very short and hence it was no possible to design the maximum number of individual sgRNAs. The first iteration of the library was [published in Nature Communications, 2020](https://www.nature.com/articles/s41467-020-15491-7).

# Quality control

## Data import

Load required packages.

```{r, message = FALSE }
library(tidyverse)
library(lattice)
library(latticeExtra)
library(latticetools)
```

Load raw data. The main table contains already normalized quantification of all sgRNAs, fold change, multiple hypothesis corrected p-values, and fitness score. Contrary to the processing of [our first CRISPRi library V1](https://github.com/m-jahn/R-notebooks), much of the functionality from the notebook was transferred into the [new CRISPRi library pipeline on github](https://github.com/m-jahn/CRISPRi-lib-pipe).

```{r}
load("../data/input/DESeq2_result.Rdata", )
df_main <- DESeq_result_table; rm(DESeq_result_table)
```


```{r, echo = FALSE}
# custom ggplot2 theme that is reused for all later plots
custom_colors = c("#E7298A", "#66A61E", "#E6AB02", "#7570B3", "#666666", "#1B9E77", "#D95F02", "#A6761D")
custom_theme <- function(base_size = 12, base_line_size = 1.0, base_rect_size = 1.0, ...) {
  theme_light(base_size = base_size, base_line_size = base_line_size, base_rect_size = base_rect_size) + theme(
    plot.margin = unit(c(12,12,12,12), "points"),
    axis.ticks.length = unit(0.2, "cm"),
    axis.ticks = element_line(colour = grey(0.4), linetype = "solid", lineend = "round"),
    axis.text.x = element_text(colour = grey(0.4), size = 10),
    axis.text.y = element_text(colour = grey(0.4), size = 10),
    panel.grid.major = element_line(size = 0.6, linetype = "solid", colour = grey(0.9)),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(linetype = "solid", colour = grey(0.4), fill = NA, size = 1.0),
    panel.background = element_blank(),
    strip.background = element_rect(fill = grey(0.4), colour = grey(0.4)),
    strip.text = element_text(colour = "white", size = 10, margin = unit(rep(3,4), "points")),
    legend.text = element_text(colour = grey(0.4), size = 10),
    legend.title = element_text(colour = grey(0.4), size = 10),
    ...
  )
}
```


## Data annotation

Different annotation columns are added to the main data frame, including a short sgRNA identifier (excluding the position on the gene), an sgRNA index (1 to 5), and genome annotation from Uniprot. Note: The Uniprot data can also be dynamically downloaded for every update of this pipeline using their very simple API:
`read_tsv("https://www.uniprot.org/uniprot/?query=taxonomy:1111708&format=tab")`.

```{r, message = FALSE}
df_main <- df_main %>%
  # correct an error in sgRNA naming
  mutate(sgRNA = gsub('â€', '2', sgRNA)) %>%
  # split sgRNA names into target gene and position
  separate(sgRNA, into = c("sgRNA_target", "sgRNA_position"), sep = "\\|",
    remove = FALSE) %>%
  
  # add sgRNA index number (1 to maximally 5) and type
  group_by(sgRNA_target) %>%
  mutate(
    sgRNA_index = sgRNA_position %>% as.numeric %>% as.factor %>%
    as.numeric,
    sgRNA_type = if_else(grepl("^nc_", sgRNA), "ncRNA", "gene")) %>%

  # map trivial names to LocusTags using a manually curated list
  left_join(
    read_tsv("../data/input/mapping_trivial_names.tsv", col_types = cols()),
    by = c("sgRNA_target" = "gene")) %>%
  
  # one more join, this time with the annotation db
  # containing uniprot and categorial (KEGG Brite) data
  left_join(read_csv("../../sgRNA_library/raw_data/Synechocystis_PCC6803_genome_annotation_20190614.csv")[c(1,4:6,11,20,22,27:32)], 
    by = c("locus" = "GeneID")) %>% ungroup %>%
  
  # remove some empty rows (NA targets)
  filter(!is.na(sgRNA_target))

head(df_main)
```


## Number of sgRNAs

Each gene is represented by up to five sgRNAs. We can test if all or only some of the 5 sgRNAs are "behaving" in the same way in the same conditions, more mathematically speaking we can estimate the correlation of every sgRNA with another. First let's summarize how many genes have 5, 4, 3 sgRNAs and so on associated with them.

```{r, , fig.width = 6, fig.height = 3.5, message =FALSE}
# N unique sgRNAs in dataset
paste0("Number of unique sgRNAs: ", unique(df_main$sgRNA) %>% length)

# N genes with 1,2,3,4 or 5 sgRNAs
df_main %>%
  group_by(sgRNA_type, sgRNA_target) %>%
  summarize(n_sgRNAs = length(unique(sgRNA_position))) %>%
  count(n_sgRNAs) %>% filter(n_sgRNAs <= 5) %>%
  ggplot(aes(x = factor(n_sgRNAs), y = n, fill = factor(n_sgRNAs),
    label = n)) +
  geom_col(show.legend = FALSE) +
  geom_text(size = 3, nudge_y = 100) +
  facet_grid(~sgRNA_type) +
  custom_theme() +
  scale_fill_manual(values = custom_colors)
```

## Correlation of sgRNAs

Different methods can be used to estimate similarity between samples (sgRNAs). For example, factor analysis is a method to dissect underlying sources of variation within the dataset, and the contribution to overall variation. The most famous example is principal component analysis (PCA). More simple is to use the correlation coefficient of sgRNAs to each other to see if one of the sgRNAs contributes stronger to overall variation. The first gene in the data set, `aat`, has for example 5 sgRNAs with one of them (number 3) showing a different depletion pattern over time. This sgRNA should get a lower weight.

```{r, fig.width = 8, fig.height = 4}
df_main %>% filter(sgRNA_target == "aat") %>%
  mutate(sgRNA_index = factor(sgRNA_index)) %>%
  ggplot(aes(x = time, y = log2FoldChange, color = sgRNA_index)) +
  geom_line(size = 1) + geom_point(size = 2) +
  facet_wrap(~ condition, ncol = 4) +
  custom_theme() +
  scale_color_manual(values = custom_colors)
```

Another example is a strictly an apparently strictly essential gene, encoding the ribosomal protein `rps10`. Most of the sgRNA repressor strains are depleted, the correlation between sgRNAs is very high.

```{r, fig.width = 8, fig.height = 4}
df_main %>% filter(sgRNA_target == "rps10") %>%
  mutate(sgRNA_index = factor(sgRNA_index)) %>%
  ggplot(aes(x = time, y = log2FoldChange, color = sgRNA_index)) +
  geom_line(size = 1) + geom_point(size = 2) +
  facet_wrap(~ condition, ncol = 4) +
  custom_theme() +
  scale_color_manual(values = custom_colors)
```

A correlation score can be calculated by by computing the correlation coefficient of all sgRNAs to each other.
This score is robustly summarized by taking the median, and rescaling it from the respective minima and maxima [-1, 1] to [0, 1].
This serves as weight for each sgRNA to calculate the (global) weighted mean of log2 FC over all sgRNAs. The following example shows the correlation matrix for the 5 `rps10` sgRNAs, and their weights.

```{r, fig.width = 4, fig.height = 4}
cor_matrix <- df_main %>% filter(sgRNA_target == "rps10") %>% ungroup %>%
  select(sgRNA_index, log2FoldChange, group) %>%
  pivot_wider(names_from = group, values_from = log2FoldChange) %>%
  arrange(sgRNA_index) %>% column_to_rownames("sgRNA_index") %>%
  as.matrix %>% t %>% cor(method = "pearson")

weights <- cor_matrix %>% replace(., . == 1, NA) %>%
  apply(2, function(x) median(x, na.rm = TRUE)) %>%
  scales::rescale(from = c(-1, 1), to = c(0, 1))

# plot heatmap
lattice::levelplot(cor_matrix,
  col.regions = colorRampPalette(custom_colors[c(1,5,2)])(20))

# print weights
weights
```

-----------

Now we can create a function that will compute weights for all sgRNAs, and add the weights to the data set.

```{r, warning = FALSE}
determine_weight <- function(index, value, group) {
  # make correlation matrix
  df <- data.frame(index = index, value = value, group = group)
  cor_matrix <- pivot_wider(df, names_from = group, values_from = value) %>%
    arrange(index) %>% column_to_rownames("index") %>%
    as.matrix %>% t %>% cor(method = "pearson")
  
  # determine weights
  weights <- cor_matrix %>% replace(., . == 1, NA) %>%
    apply(2, function(x) median(x, na.rm = TRUE)) %>%
    scales::rescale(from = c(-1, 1), to = c(0, 1)) %>%
    enframe("index", "weight") %>% mutate(index = as.numeric(index)) %>%
    mutate(weight = replace(weight, is.na(weight), 1))
  
  # return vector of weights the same order and length 
  # as sgRNA index vector
  left_join(df, weights, by = "index") %>% pull(weight)
}

df_main <- df_main %>% group_by(sgRNA_target) %>%
  mutate(sgRNA_weight = determine_weight(sgRNA_index, log2FoldChange, group))
```

----------

Plot the weight of each sgRNA to see if there's position bias. There is none.

```{r, fig.width = 5, fig.height = 4}
df_main %>%
  select(sgRNA_target, sgRNA_index, sgRNA_weight) %>%
  filter(sgRNA_index <= 5) %>%
  distinct %>%
  # plot
  ggplot(aes(x = factor(sgRNA_index), y = sgRNA_weight)) +
  geom_violin() + 
  coord_cartesian(ylim = c(-0.05, 1.05)) +
  stat_summary(fun.data = mean_sdl, geom = "pointrange",
    size = 0.7, color = "red") +
  custom_theme()
```

We can also quantify how many genes have strongly correlated sgRNAs and how many have outliers. In order to do this, the median weight of the (up to) 5 sgRNAs per gene is plotted. Generally, the median weight ranges between 0.5 and 1.0, showing on average good correlation.

```{r, fig.width = 5, fig.height = 4}
df_main %>%
  select(sgRNA_target, sgRNA_index, sgRNA_weight) %>%
  filter(sgRNA_index <= 5) %>%
  distinct %>% group_by(sgRNA_target) %>%
  summarize(
    median_sgRNA_weight = median(sgRNA_weight),
    min_sgRNA_weight = min(sgRNA_weight)
  ) %>%
  # plot
  ggplot(aes(x = median_sgRNA_weight)) +
  geom_histogram(bins = 40, fill = custom_colors[1], alpha = 0.7) +
  custom_theme()
```

## Position bias of sgRNA repression strength

Another question is if the binding position of the sgRNAs is correlated to the strength of repression. In other words, if sgRNAs binding closer to the promoter have a stronger ability to repress a gene. We perform this analysis for genes only, as the absolute majority has 5 sgRNAs. We also use only the latest time point with --presumably-- the strongest effect on repression.

```{r, fig.width = 5, fig.height = 4}
df_main %>%
  filter(sgRNA_index <= 5, sgRNA_type == "gene", time == 10) %>%
  ggplot(aes(x = factor(sgRNA_index), y = log2FoldChange)) +
  geom_boxplot(notch = FALSE, outlier.shape = ".") +
  coord_cartesian(ylim = c(-2, 2)) +
  stat_summary(fun.data = mean_sdl, geom = "pointrange",
    size = 0.7, color = "red") +
  custom_theme()
```



## Summarize sgRNA fitness to gene fitness

With the weight per sgRNA, we can compute the **weighted mean of all sgRNAs**, but also the standard **arithmetic mean** for comparison. Metrics are calculated for log2 FC, and fitness.

```{r}
df_gene <- df_main %>%
  
  # keep all annotation columns
  group_by(sgRNA_target, sgRNA_type, locus, condition, time, Process, 
    Pathway, Protein, Gene.names, Gene.ontology.IDs, Length, MolWeight, location, start_bp, end_bp) %>%
  
  # summarize FC and fitness with and without weights
  summarize(.groups = "drop",
    mean_log2FoldChange = mean(log2FoldChange),
    wmean_log2FoldChange = weighted.mean(log2FoldChange, sgRNA_weight),
    sd_log2FoldChange = sd(log2FoldChange),
    mean_fitness = mean(fitness),
    wmean_fitness = weighted.mean(fitness, sgRNA_weight),
    sd_fitness = sd(fitness)
  )
```

A comparison of log2 FC aggregated by weighted mean or by regular mean shows marginal differences between the two metrics. The plot below shows the first 36 genes by alphabetical order, for one selected condition only.

```{r, fig.width = 8, fig.height = 8}
df_gene %>% filter(
    Gene.names %in% unique(.data[["Gene.names"]])[1:36],
    condition == "1% CO2, BG11, 1000uE") %>%
  pivot_longer(cols = matches("mean_log2FoldChange"), names_to = "metric", values_to = "log2 FC") %>%
  mutate(metric = str_remove(metric, "_log2FoldChange")) %>%
  ggplot(aes(x = time, y = `log2 FC`, 
    ymin = `log2 FC`-sd_log2FoldChange, ymax = `log2 FC`+sd_log2FoldChange, color = metric)) +
  geom_linerange(size = 1) + geom_line(size = 1) + geom_point(size = 2) +
  facet_wrap(~ sgRNA_target, ncol = 6) +
  custom_theme(legend.position = "top") +
  coord_cartesian(ylim = c(-5, 5)) +
  scale_color_manual(values = custom_colors)
```

The same control can be performed for gene fitness, that is, the AUC of log2 FC over all time points, for each individual sgRNA. Fitness was also summarized using the mean, or weighted mean, for each of the 36 first genes by alphabetical order and one selected condition only. We can conclude from the plot below that mean and weighted mean only result in marginal difference in estimation of fitness, and continue with the weighted versions for all following analyses.

```{r, fig.width = 8, fig.height = 4}
df_gene %>% filter(
    Gene.names %in% unique(.data[["Gene.names"]])[1:36],
    condition == "1% CO2, BG11, 1000uE", time == 0) %>%
  pivot_longer(cols = matches("mean_fitness"), names_to = "metric", values_to = "fitness") %>%
  mutate(metric = str_remove(metric, "_fitness")) %>%
  ggplot(aes(x = sgRNA_target, y = fitness, 
    ymin = fitness-sd_fitness, ymax = fitness+sd_fitness, fill = metric, color = metric)) +
  geom_col(position = "dodge") +
  geom_errorbar(position = "dodge", size = 1) +
  custom_theme(legend.position = "top") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_fill_manual(values = custom_colors[1:2]) +
  scale_color_manual(values = custom_colors[1:2])
```

## Global distribution of gene fitness

```{r, fig.width = 8, fig.height = 4}
df_gene %>% filter(time == 0) %>%
  ggplot(aes(x = wmean_fitness, fill = sgRNA_type)) +
  geom_histogram(bins = 100) +
  coord_cartesian(xlim = c(-2, 2), ylim = c(0, 1000)) +
  facet_wrap( ~ condition, ncol = 4) +
  custom_theme() +
  scale_fill_manual(values = custom_colors[3:4])
```


## Behavior of control sgRNAs

Ten sgRNAs were included in the library that have no gene-specific/random (?) targets. The following plot shows that these negative controls do not have an effect on strain fitness.


```{r, fig.width = 8, fig.height = 4}
df_main %>% filter(grepl("ctrl", sgRNA_target)) %>%
  ggplot(aes(x = time, y = log2FoldChange, color = sgRNA_target)) +
  geom_line(size = 1) + geom_point(size = 2) + ylim(-3, 3) +
  facet_wrap(~ condition, ncol = 4) +
  custom_theme() +
  scale_color_manual(values = rep_along(1:10, custom_colors))
```

# Unsupervised clustering of genes

## Cluster genes by similarity

```{r, fig.width = 8, fig.height = 1.6}
# generate colorpalette for heatmap
heat_cols <- colorspace::diverging_hcl(n = 7, h = c(255, 12), c = c(50, 80), l = c(20, 97), power = c(1, 1.3))

# create a matrix from wide fitness data for plotting heatmap
mat_heatmap <- df_gene %>% filter(time == 0, !is.na(locus)) %>%
  select(locus, condition, wmean_fitness) %>%
  mutate(wmean_fitness = wmean_fitness %>%
    replace(., . > 3, 3) %>% replace(., . < -3, 3)) %>%
  pivot_wider(names_from = condition, values_from = wmean_fitness) %>%
  #filter(if_any(.cols = matches("uE$"), ~ !between(., -1.5, 1.5))) %>%
  column_to_rownames(var = "locus") %>%
  as.matrix

# create cluster for reordering
mat_cluster <- mat_heatmap %>% dist %>% hclust(method = "ward.D")
mat_heatmap <- mat_heatmap[order.dendrogram(as.dendrogram(mat_cluster)), c(1,3,2,4,6,5,7)]

# plot heatmap
plot_heatmap <- levelplot(mat_heatmap,
  par.settings = custom.colorblind(),
  col.regions = colorRampPalette(heat_cols)(16),
  at = seq(-3, 3, 0.5), aspect = "fill",
  xlab = paste0("sgRNA (", nrow(mat_heatmap),")"), ylab = "", scales = list(x = list(draw = FALSE)),
  panel = function(x, y, z, ...) {
    panel.levelplot(x, y, z, ...)
    panel.abline(h = 1:5+0.5, col = "white", lwd = 1.5)
  }
)

print(plot_heatmap)
```
