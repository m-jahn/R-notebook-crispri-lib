---
title: "CRISPRi library additional tests"
output:
  html_notebook:
    toc: yes
---


## Description

The purpose of this R markdown notebook is to provide a trackable, reproducible,
and comprehensive documentation of data processing steps for experiments carried 
out using a CRISPRi sgRNA library in the  cyanobacterium _Synechocystis_ sp. PCC6803.

This is an additional part of the pipeline where other tracks are explored by
blending the fitness results of the CRISPRi library with protein abundance
or protein variability. The additional data set used here is a proteomics study 
from [Jahn et al., Cell Reports, 2018](https://linkinghub.elsevier.com/retrieve/pii/S2211124718314852).
The idea is that gene/protein essentiality could correlate with variability in
protein abundance. One scenario would be that 'core proteins' are both essential and
less variable in abundance as they are required under all possible conditions.
The 'core proteome' (around 400 proteins in _E. coli_) was reported to  be mostly
allosterically regulated instead of transcriptionally.


```{r, results = 'hide', message = FALSE}
# LOAD PACKAGES

library(lattice)
library(latticeExtra)
library(grid)
library(tidyverse)
library(Rtools)
library(factoextra)
library(clusterProfiler)
library(limma)
```


## Correlation between gene fitness and gene expression variability

Preprocessed data in the form of reads per gene was summarized and annotated 
in pipeline 1. It includes mean read fraction, log2 FC and p-value calculated 
using DESeq2. Genome annotation was added based on uniprot and cyanobase annotation
of the reference genome for _Synechocystis_ sp. PCC6803. 

----------

#### Loading and merging proteomics data

```{r, message = FALSE, warning = FALSE}
# load CRISPRi library data
load(file = "../processed_data/CRISPRi_library_df_cluster.Rdata")

# exclude ncRNAs from analysis
df_all <- df
df <- df %>% filter(!grepl("^Entry", sgRNA))
```


```{r, message = FALSE, warning = FALSE}
# load MS data from Cell Reports paper and combine with library
df_ms <- read_csv("../../../../../Experiments/20171204_MS_CO2/CO2_light/analysis/diffacto_weightedsum/df_long_massfrac.csv") %>%
  
  # we can try both light and CO2-related regulation (one ANOVA test per limitation and protein)
  # -------------------------
  # this block is for LIGHT
  # -------------------------
  filter(sample == "light", light %in% c(300, 100)) %>%

  # change sample annotation from [100, 300] to [L100, L300]
  mutate(condition = recode(light, `300` = "L300", `100` = "L100")) %>%

  # rename a column
  rename(locus = protein) %>%

  # select only the interesting columns
  select(locus, condition, mean.mass.fraction.norm, ANOVA, ANOVA.adj) %>%
  
  # -------------------------
  # this block is for CO2
  # -------------------------
  # filter(sample == "CO2", concentration == 1) %>% 
  # 
  # # rename a column
  # rename(locus = protein) %>%
  # 
  # # select only the interesting columns
  # select(locus, mean.mass.fraction.norm, ANOVA, ANOVA.adj) %>%
  # -------------------------
  
  # merge with df
  left_join(df, .) %>%
  
  # filter for L100 and L300 only
  filter(condition %in% c("L100", "L300"))

  
# test if mass fraction sums up to _around 1_ (also depends on intersection
# between proteomics and CRISPRi library gene sets)
df_ms %>% group_by(condition, timepoint, induction, sgRNA_index) %>% 
  summarise(sum(mean.mass.fraction.norm, na.rm = TRUE)) %>% head


# # optionally reduce data to only the sgRNA with the smallest effect
# df_ms <- df_ms %>% group_by(condition, induction, sgRNA_short) %>%
# summarise(
#   fitness_score = min(fitness_score),
#   ANOVA.adj = min(ANOVA.adj)
# )

```

----------

#### Correlation between change over light conditions and essentiality

Different metrics could be used to determine the extent of a protein changing 
abundance over light conditions. The MS dataset contains an ANOVA p-value that is 
lower (more significant) the more a protein changes abudnance over light intensity/
growth rate (5 light intensities were originally tested: L60, L100, L200, L300 
and L1000). The p-value obtained from ANOVA is the same for all conditions. It is
therefore not neccessary to include all possible light conditions. If all sgRNAs 
are mapped to their corresponding proteins (2 sgRNAs per protein), no correlation is
visible. Also not, if optionally only the more depleted of the two sgRNAs per protein
are selected.

```{r, fig.width = 6, fig.height = 3.5}
# filter dataset for 1 time point only (fitness score is identical
# for all time points of 1 condition)
df_ms %>% filter(timepoint == 0) %>%
  
  xyplot(-log10(ANOVA.adj) ~ fitness_score | factor(condition, unique(condition)), .,
  as.table = TRUE, groups = induction, 
  between = list(x = 0.5, y = 0.5),
  par.settings = custom.lattice, pch = 19, cex = 0.3,
  scales = list(alternating = FALSE),
  #xlim = c(-9, 4), ylim = c(-9, 4),
  xlab = "fitness", ylab = bquote(-log[10] ~ "ANOVA p-value"),
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyplot(x, y, ... )
    panel.key(c("induced", "uninduced"), pch = 19, corner = c(0.1, 0.9))
  }
)
```

However it is possible to refine the approach by selecting subsets of sgRNAs or 
proteins. In the following step, proteins are binned by ANOVA log10 -p-value,
and fitness score distribution evaluated as box and whisker plot. Here, a trend
can be seen in the form of more significantly regulated genes (higher -log10 p-value)
having reduced median fitness.

```{r, fig.width = 5, fig.height = 4}
# customize plotting colors a bit
custom.lattice <- custom.lattice()
custom.lattice$box.rectangle$col = rep(c("#CC476B", "#00526D"), c(3,2))
custom.lattice$box.umbrella$col = rep(c("#CC476B", "#00526D"), c(3,2))
custom.lattice$box.rectangle$lwd = 1.5
custom.lattice$box.umbrella$lwd = 1.5


# filter dataset for 1 time point only (fitness score is identical
# for all time points of 1 condition)
plot_fitness_ANOVA_bw <- df_ms %>% filter(timepoint == 0) %>%
  
  # bin into groups by -log10 p-value
  mutate(ANOVA_bin = cut(ANOVA.adj, breaks = c(1,0.1,0.05,0.01,0.001,0))) %>%
  
  xyplot(fitness_score ~ factor(ANOVA_bin) | factor(condition) %>% 
      paste0(" - ", recode(induction, i = "induced", u = "uninduced")), .,
    as.table = TRUE, between = list(x = 0.5, y = 0.5),
    par.settings = custom.lattice, lwd = 1.5, 
    scales = list(alternating = FALSE, x = list(rot = 30, cex = 0.7)),
    xlab = bquote(-log[10] ~ "ANOVA p-value"), ylab = "fitness",
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.violin(x, y, horizontal = FALSE, border = NA, col = grey(0.7, 0.5))
      panel.bwplot(x, y, horizontal = FALSE, pch = "|", do.out = FALSE, ... )
      panel.pvalue(x, y, fixed_pos = -1, std = 5, 
        col = rep(c("#CC476B", "#00526D"), c(3,2))
      )
    }
  )

print(plot_fitness_ANOVA_bw)
```


As a follow-up, the most regulated proteins were selected and the fitness of the 
corresponding sgRNAs was plotted as barchart (groups in red from above, 
$p_{value} \leq 0.05$). 



```{r, fig.width = 5, fig.height = 4}
# customize plotting colors a bit
custom.lattice$box.rectangle$col = "#CC476B"#"#00526D"
custom.lattice$box.umbrella$col = "#CC476B"#"#00526D"

# filter dataset for 1 time point only (fitness score is identical
# for all time points of 1 condition)
plot_fitness_ANOVA_pw <- df_ms %>% 
  
  # filter also for most regulated genes = p-value <= 0.01
  filter(timepoint == 0, induction == "i", ANOVA.adj <= 0.05) %>% 
  
  # arrange genes by mean fitness over pathway
  group_by(Process.abbr) %>% 
  mutate(
    mean_fitness = mean(fitness_score, na.rm = TRUE),
    n_sgRNAs = length(unique(sgRNA))) %>%
  arrange(mean_fitness) %>%
  
  # plot fitness per pathway
  xyplot(fitness_score ~ paste0(Process.abbr, " (", n_sgRNAs, ")") %>% factor(., unique(.)) | 
      paste0(condition, " - induced"), .,
    as.table = TRUE, between = list(x = 0.5, y = 0.5),
    par.settings = custom.lattice, lwd = 1.5, layout = c(1,2),
    scales = list(alternating = FALSE, x = list(rot = 30, cex = 0.7)),
    xlab = "cyanobase pathway", ylab = "fitness",
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.violin(x, y, horizontal = FALSE, border = NA, col = grey(0.7, 0.5),... )
      panel.bwplot(x, y, horizontal = FALSE, pch = "|", do.out = FALSE, ... )
    }
  )

print(plot_fitness_ANOVA_pw)
```

```{r, results = 'hide', include = FALSE, eval = FALSE}
svg("../figures/supplemental/Supplemental_figure_prot_regulation_light.svg", width = 5, height = 7)
print(plot_fitness_ANOVA_bw, position = c(0, 0.48, 1, 1.04), more = TRUE)
print(plot_fitness_ANOVA_pw, position = c(0, 0, 1, 0.53))
grid.text(label = c("a", "b"), x = c(0.03, 0.03), y = c(0.98, 0.5), gp = gpar(cex = 1.3))
dev.off()
```

----------

**Supplementary Figure. Highly regulated proteins have lower average fitness.**
**a** Fitness score of sgRNAs broken down by protein variability. Protein variability
was estimated using a proteomics study with measurement of protein abundance over several
light conditions (Jahn et al., Cell Reports, 2018). Here, the adjusted p-value from 
ANOVA over all light conditions was used as a metric for variability. For this comparison,
every sgRNA was mapped to its corresponding protein. Red, proteins with $p_{value} \leq 0.05$).
Blue, proteins with $p_{value} > 0.05$).
**b** Fitness score of sgRNAs associated with most significantly changing proteins
($p_{value} \leq 0.05$, red in (A), broken down by cyanobase pathways.
In brackets, number of unique sgRNAs per pathway.

----------

## Determine mutant growth rate from depletion over time

The main dataset contains measurements of thousands of sgRNA mutants over time.
The proportion of these mutant sub-populations of the total population 
changes over time depending on their individual growth rate. If a mutant grows faster
than the population average, it will outcompete the other mutants in terms of growth
and enrich in the population. Likewise, mutants with a growth defect be diluted over time
eventually get depleted from the population. Theoretically, this problem is similar
to the mathematical concept of half-life as it is known from nuclear decay. At a certain
rate (half-life), an unstable isotope will break apart into a more stable one releasing 
radiation.

#### Mathematical concept

All parameters to determine the growth rate of each individual mutant are known.
The main parameters are the average growth rate ($\mu$, equals dilution rate ($D$) 
of the population, and the relative fraction of each mutant ($FC$) of the total population 
at the initial and later time points ($t_0, t_i$). 
If a mutant will not grow at all, it is depleted from the library
at the rate of population growth ($D_{total}$). If it grows at a slower rate $D_{mutant}$,
it is depleted from the library at rate $D_{diff}$.

$$ D_{diff} = D_{total} - D_{mutant} $$

The depletion of a mutant from the library can be modeled for arbitrary time points,
where the mutant fraction $F_t$ at time point $t$ becomes

$$ F(t) = F(_{t=0}) \times (1-({D_{total}-D_{mutant}}))^{t} $$
For example, population fraction $F$ after 10 h growth with a population growth rate 
of $D_{total} = 0.1$, a mutant growth rate of $D_{mutant} = 0.05$, and inital population 
fraction of $F(t=0) = 0.1$ is $F(10 h) = 0.1 \times (1-(0.1-0.05))^{10} = 0.059$.
This is effectively a growth model that can be fitted to each sgRNA using the known 
parameters $F(t=0)$, $D_{total}$, and $F(t)$, and solving for $D_{mutant}$. 
To make things easier, it is possibe to use the fold change (FC) as normalized 
measure of read fraction. Then initial population fraction becomes 1 ($F(t=0) = 1$) 
and can be removed from the equation. To fit this model to sgRNA depletion, 
R's standard non-linear fitting system `nls()` can be used.

#### Implementation

We prepare a reduced data frame with time in days being converted to time in 
hours (to match growth rate per hour).

```{r}
df_mu <- df %>% ungroup %>% 
  mutate(timepoint = timepoint * 24) %>%
  select(condition, timepoint, induction, sgRNA, sgRNA_short, sgRNA_index, locus, 
    FC, average_growth_rate, Process.abbr)
  
# use a wrapper function for nls() that we can apply on whole data frame
fit_mu <- function(time, pop_mu, FC) {
  # wrap function in a tryCatch statement to handle max iteration errors
  model <- tryCatch(error = function(e) {NULL},
    nls(
      formula = FC ~ (1 - (pop_mu - mut_mu))^time,
      data = data.frame(time = time, pop_mu = pop_mu, FC = FC),
      start = list(mut_mu = 0.01)
    )
  )
  # test for errors and return result
  if (is.null(model)) {
    return(NA)
  } else {
    summary(model)[["parameters"]][[1]]
  }
}


# add modeled depletion to data frame using fitted mutant growth rate
df_mu <- df_mu %>% group_by(condition, induction, sgRNA) %>%
  mutate(
    mutant_growth_rate = fit_mu(timepoint, average_growth_rate, FC),
    FC_fit = (1 - (average_growth_rate - mutant_growth_rate))^timepoint
  )
  
# preview
df_mu %>% head

# save the data
write_csv(df_mu, "../processed_data/CRISPRi_library_df_growthrates.csv")

```


```{r, include = FALSE, eval = FALSE}
# can also load previously computed result table
df_mu <- read_csv("../processed_data/CRISPRi_library_df_growthrates.csv")
```

----------

The result from the growth models is the estimated parameter, the mutant growth rate,
and the predicted depletion/enrichment over time in FC (`FC_fit`). 
However, a first necessary check is to see how many genes failed to get a growth model fitted. 
Second, the distribution of mutant growth rates can be plotted.


```{r}
# check how many models failed (mostly due to NA/missing values)
df_mu %>% group_by(condition, induction) %>% filter(timepoint == 0) %>%
  summarise(
    successful_models = sum(!is.na(mutant_growth_rate)),
    failed_models = sum(is.na(mutant_growth_rate))
  )
```


```{r, fig.width = 4, fig.height = 3}
# customize plotting colors a bit
custom.lattice <- custom.lattice()
custom.lattice$box.rectangle$col = "#00526D"
custom.lattice$box.umbrella$col = "#00526D"
custom.lattice$box.rectangle$lwd = 1.5
custom.lattice$box.umbrella$lwd = 1.5

# plot mutant growth rates
xyplot(mutant_growth_rate ~ paste0(condition, "\n", induction) %>% factor,
  df_mu %>% ungroup %>%
    filter(timepoint == 0, condition != "LD"), groups = induction,
  as.table = TRUE, between = list(x = 0.5, y = 0.5),
  par.settings = custom.lattice, lwd = 1.5,
  xlab = "condition", ylab = "µ_mutant [h-1]", 
  ylim = c(0, 0.1),
  scales = list(alternating = FALSE),
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.violin(x, y, horizontal = FALSE, border = NA, col = grey(0.7, 0.5),... )
    panel.bwplot(x, y, horizontal = FALSE, pch = "|", do.out = FALSE, ... )
  }
)
```

----------

#### Growth rate of sgRNA mutants for selected pathways

We can plot the _predicted_ depletion/enrichment over time _versus_ the _actual_ 
depletion/enrichment. Different sets of interesting genes or pathways could be
selected. For a start, a selection of genes for **photorespiration** and for
**Calvin cycle** related genes can be created. The next step is to compare the 
fitted growth rates for individual mutants, for example between induced and non-induced
conditions.

#### Faster growing sgRNA mutants

A few clones actually gained a condition-dependent fitness advantage over the 
population average. In the case of the turbidostat, cells are selected for maximum
specific growth rate and maximizing fitness is therefore reduced to maximizing
steady-state growth rate for a particular condition. In the next paragraph, 
not only mutants for specific pathways but also faster-growing mutants are 'isolated'.

```{r}
# Photorespiration genes (extracted from Hagemann papers)
list_photores <- c(
  "sll0404", "slr0806", "sll0171", "slr0229", "slr1348", 
  "sll1349", "sll1981", "slr2088", "sll1559", "slr1931"
)

# Calvin cycle genes
list_calvin <- c(
  "sll1525", "slr0012", "slr0009", "slr0394", "sll1342",
  "slr0884", "slr0943", "sll0018", "slr0952", "slr2094",
  "sll1070", "slr0194", "ssl2153", "slr0783", "sll0807",
  "slr1793", "sll0587", "sll1275", "slr0752", "slr1945",
  "slr0084", "slr1349", "slr1124", "sll0395", "slr1748"
)

# faster growing mutants
list_faster <- c(
  "sll1968", "sll1969", "slr1916", "slr1340", "ssl2982"
)
```


```{r, fig.width = 6.5, fig.height = 4.5}
# plot fitted model and actual depletion together for subset of sgRNAs
plot_mutant_mu <- lapply(c("FC", "FC_fit"), function(var) {
  xyplot(log2(get(var)) ~ timepoint | sgRNA_short, 
    df_mu %>% ungroup %>% filter(locus %in% list_faster, condition == "L300"),
    groups = paste(induction, sgRNA_index), col = rep(c("#00526D", "#CC476B"), each = 2),
    as.table = TRUE, between = list(x = 0.3, y = 0.3), layout = c(5, 1),
    par.settings = custom.lattice, type = "l", lwd = 2,
    xlab = "time [h]", ylab = bquote(log[2] ~ "FC"), 
    xlim = c(0, 400), ylim = c(-5, 10),
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.key(c("induced", "uninduced"), corner = c(0.1,0.05), 
        points = FALSE, lines = TRUE, cex = 0.6)
    }
  )
})

print(plot_mutant_mu[[1]], position = c(0,0.5,1,1), more = TRUE)
print(plot_mutant_mu[[2]], position = c(0,0,1,0.5))
```

Comparison of growth rate for the selected genes. Mutant growth rate is
aggregated as mean and standard deviation of the two sgRNAs. Induced _versus_ uninduced
condition is plotted. More informative than plotting actual growth rates is plotting
the % of change in growth rate compared to the population average. The table with mutant
growth rate of all selected strains is saved as a *Supplementary Data* table.

```{r, fig.width = 6, fig.height = 8}
plot_mutant_mu_2 <- lapply(list(list_calvin, list_photores, list_faster), function(genes) {
  
  # adjust scale to selected gene set
  if ("slr1916" %in% genes) ylim = c(90, 130) else ylim = c(-50, 150)
  
  df_mu %>% ungroup %>%
  
  # select subset of sgRNA
  filter(locus %in% genes, condition %in% c("L100", "L300")) %>%
  
  # plot relative change in mutant growth rate compared to pop average
  xyplot(mutant_growth_rate/average_growth_rate*100 ~ factor(sgRNA_short) | condition, .,
    groups = induction, 
    as.table = TRUE, between = list(x = 0.3, y = 0.3), 
    par.settings = custom.lattice, layout = c(1, 2),
    pch = 19, col = c("#00526D", "#CC476B"),
    #main = "Mutant growth rate obtained from depletion/enrichment model",
    xlab = "", ylab = "µ [% pop. average]", 
    ylim = ylim, 
    scales = list(alternating = FALSE, x = list(rot = 30, cex = 0.7)),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(h = 100, col = grey(0.5), lty = 2)
      panel.superpose(x, y, ...)
    }, panel.groups = function(x, y, ...) {
      panel.errbars(x, y, ewidth = 0, ...)
    }
  )
  
})

print(plot_mutant_mu_2[[1]], position = c(0,0.64,1,1.01), more = TRUE)
print(plot_mutant_mu_2[[2]], position = c(0,0.31,1,0.68), more = TRUE)
print(plot_mutant_mu_2[[3]], position = c(0,0,1,0.36))
grid.text(label = c("a", "b", "c"), x = c(0.03, 0.03, 0.03), 
  y = c(0.98, 0.66, 0.33), gp = gpar(cex = 1.3))
```

----------

**Supplemental Figure.** 
Estimated growth rate of selected mutants. Mutant growth rate was determined from depletion of sgRNAs over time as described in Methods (mean and standard deviation of two sgRNAs per gene). Growth rate is displayed as % of population growth rate. Red - uninduced control, blue - induced culture. 
**a** Selected genes from the Calvin cycle. 
**b** Selected genes for photorespiration. 
**c** Selected faster growing mutants.


```{r, results = 'hide', include = FALSE}
svg("../figures/supplemental/Supplemental_figure_mutant_growth.svg", width = 6, height = 8)
print(plot_mutant_mu_2[[1]], position = c(0,0.64,1,1.01), more = TRUE)
print(plot_mutant_mu_2[[2]], position = c(0,0.31,1,0.68), more = TRUE)
print(plot_mutant_mu_2[[3]], position = c(0,0,1,0.36))
grid.text(label = c("a", "b", "c"), x = c(0.03, 0.03, 0.03), 
  y = c(0.98, 0.66, 0.33), gp = gpar(cex = 1.3))
dev.off()
```

----------

#### Saving processed data frames as Supplemental Data

1. Complete original data frame (including ncRNAs) with extra columns for
   mutant growth rate relative growth rate change in %. 
   This is **Supplemental Data S3**.

```{r, message = FALSE}
# merge master data frame with predicted growth rates
df_all <- df_mu %>% ungroup %>% 
  
  # summarize mutant growth rate as mean and stdev
  group_by(sgRNA_short, condition, induction) %>%
  summarize(
    locus = locus[1],
    population_growth_rate = average_growth_rate[1],
    mean_mutant_growth_rate = mean(mutant_growth_rate),
    stdev_mutant_growth_rate = sd(mutant_growth_rate)
  ) %>%
  
  # add relative change
  mutate(mutant_growth_rate_percent = 
    mean_mutant_growth_rate/population_growth_rate*100) %>%
  
  # select only growth rate-related columns and merge
  select(sgRNA_short, condition, induction, 
    mean_mutant_growth_rate, mutant_growth_rate_percent) %>%
  left_join(df_all, .) %>%
  
  # remove unnecessary columns
  select(-FC, -Gene.ontology.IDs, -Process.abbr, -Pathway.abbr)

# and save to disk
write_csv(df_all, "../processed_data/Supplemental_data_S3.csv")
```


2. Selected genes for photorespiation, Calvin cycle, and increased growth rate.
   This is **Supplemental Data S5**.

```{r}
df_all %>% ungroup %>% 
  
  # select subset of sgRNAs and conditions
  filter(
    locus %in% c(list_calvin, list_photores, list_faster), 
    condition %in% c("L100", "L300"),
    timepoint == 0,
    sgRNA_index == 1
  ) %>%
  
  # select only important columns
  select(sgRNA_short, condition, induction, locus, 
    average_growth_rate, mean_mutant_growth_rate, 
    mutant_growth_rate_percent) %T>% print %>% 
  
  write_csv("../processed_data/Supplemental_data_S5.csv")
```

----------


## Transcriptome of selected mutants analysed by RNA-Seq

Some genes in the sgRNA library were found to confer a growth advantage in 
competition experiments when repressed. These faster growing mutants were *pmgA*, *sll1969*, 
*slr1340*, *slr1916*, and *ssl2982*. These genes were grown in high light conditions
(300 µmol photons m<sup>-2</sup> s<sup>-1</sup>) in turbidostat regime identical to the
conditions that the complete mutant library was grown before. The mRNA of these
samples was extracted, purified and quantitatively analyzed using RNA-Seq. The
reads per gene were processed using `DESeq2` in the same way as all other CRISPRi library
samples before. The purpose of this analysis is to find differences between faster-growing
sgRNA mutants compared to the NT0 (no-target sgRNA) control. The hypothesis is that 
these mutants have an effect on global regulation of the cell.

```{r, message = FALSE}
df_rnaseq <- read_csv("../raw_data/transcriptomics_selected_mutants.csv") %>%
  
  # filter out pmgA condition and un-annotated ORFs
  filter(
    !grepl("MYO\\_|SGL\\_", Name),
    Condition != "pmgA")
  
head(df_rnaseq)
```

----------

#### Overview of mutants gene expression

We can start to explore differential regulation using a volcano plot.

```{r, fig.width = 6.5, fig.height = 2.6}
plot_volcanoplot <- df_rnaseq %>%
  
  xyplot(-log10(padj) ~ setNames(log2FoldChange, Name) | 
      factor(Condition), ., 
    as.table = TRUE, groups = Significance,
    xlab = bquote(log[2] ~ "FC"), ylab = bquote(-log[10] ~ "p-value"),
    par.settings = custom.lattice, layout = c(4, 1),
    cex = 0.6, pch = 19, col = c(grey(0.5, 0.4), "#00526D"),
    scales = list(alternating = FALSE), 
    between = list(x = 0.4, y = 0.4),
    ylim = c(-5, 55), xlim = c(-6, 6),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      # trim extremely far outside p-values to -log10(p) = 50 so that they are still
      # in visible range
      y <- replace(y, y >= 50, 50)
      panel.xyplot(x, y, ...)
      # select top diff expr genes and plot labels
      sel <- which(!between(x, -1, 1) & y >= 20 |
        (names(x) %in% c("sll1969", "slr1340", "slr1916", "ssl2982")[panel.number()]))
      panel.text(x[sel], y[sel]+5, labels = names(x[sel]), cex = 0.6, col = "#00526D")
      panel.key(c("not significant", "significant"), col = c(grey(0.6), "#00526D"),
        pch = 19, corner = c(0.1, 0.9), cex = 0.7)
    }
  )

print(plot_volcanoplot)
```

----------

Apparently, only few genes were differentially expressed in *sll1969* and *slr1340*,
while considerably more were different in mutants *slr1916*, *ssl2982* and *pmgA*
(not shown).
In the next step, we have a look at the overlap between significantly regulated 
genes between mutants. One way is to use a heat map for visual inspection and 
cluster the data according to expression similarity as was done for the complete
sgRNA library before.

```{r, fig.width = 6.5, fig.height = 1.3}
# filter for significant genes only (same critera Johannes used)
sig_genes <- df_rnaseq %>% filter(
    !between(log2FoldChange, -1, 1), padj <= 0.05) %>%
  pull(Name) %>% unique

# prepare matrix for plotting heat map and plot
sig_genes_mat <- df_rnaseq %>% filter(Name %in% sig_genes) %>%
  
  # spread to matrix
  select(Name, Condition, log2FoldChange) %>% 
  spread(Condition, log2FoldChange) %>% 
  select(Name, sll1969, slr1340, slr1916, ssl2982) %>%
  
  # reorder matrix by simple pre-clustering with hclust
  column_to_rownames("Name") %>% as.matrix %>% replace_na(0) %>%
  {.[dist(.) %>% hclust(., method = "ward.D2") %>% {.$order}, ]}


# plot genes
plot_heatmap <- levelplot(sig_genes_mat,
  col.regions = colorRampPalette(c("steelblue", grey(0.95), "darkorange"))(26),
  as.table = TRUE, aspect = "fill", at = seq(-3, 3, 0.25),
  xlab = paste0("gene (n=", length(sig_genes), ")"),
  ylab = "",
  scales = list(alternating = FALSE, x = list(draw = FALSE))
)

print(plot_heatmap)
```

The heat map shows that the mode of action seems overall similar for the first 
four genes. But *pmgA* had a different if not even inverted expression pattern and
was exlcuded from further analysis, also because RNAseq was conducted at a different
occasion than for the other genes.

The overlap in differentially expressed genes for all mutants except *pmgA*
can be quantified by correlating log2FC for all significantly regulated genes 
of each mutant against each other. 
The result shows that *ssl2982*, *slr1916*, and *slr1340* are well correlated, but 
*sll1969* and *pmgA* (*sll1968*) are not, not even with themselves.


```{r, fig.width = 6.5, fig.height = 3.25}
plot_splom <- lapply(c(FALSE, TRUE), function(s) {
  
  # filter genes conditionally
  if (s) {df_rnaseq <- filter(df_rnaseq, Name %in% sig_genes)}
  
  df_rnaseq %>% 
  
  # spread log2FC condition-wise
  select(Name, Process, Condition, log2FoldChange) %>% 
  spread(Condition, log2FoldChange) %>%
  select(sll1969:ssl2982) %>%
  
  custom_splom( ~ ., 
    main = ifelse(s, "only significant genes", "all genes")
  )
  
})

print(plot_splom[[1]], split = c(1,1,2,1), more = TRUE)
print(plot_splom[[2]], split = c(2,1,2,1))
```

Additionally, we can also quantify the overlap of DEG between the four mutants,
in a type of Venn diagram analysis.

```{r}
df_rnaseq %>% 
  
  # filter only sign. genes
  filter(Name %in% sig_genes) %>%
  select(Name, Condition, Significance) %>%
  
  # group by gene and count significant hits per condition (max 4)
  group_by(Name) %>% 
  summarize(
    hits = Condition[which(Significance == "Yes")] %>% stringr::str_flatten(collapse = ", ")
  ) %>% pull %>% table %>% sort(decreasing = TRUE) %>% enframe
```

----------

#### Clustering and KEGG pathway enrichment


The next step is to look for meaningful genes or patterns that could explain the
observed increased growth rate. We can look for interesting clusters from the 
subset of significantly regulated genes. We can see what automated (and objective) 
methods will suggest as optimal number of clusters when using `kmeans` instead of
`hclust` (this method does not support `hclust`).


```{r, fig.width = 8, fig.height = 2.5}
gridExtra::grid.arrange(ncol = 3,
  fviz_nbclust(sig_genes_mat, kmeans, method = "wss"),
  fviz_nbclust(sig_genes_mat, kmeans, method = "gap_stat"),
  fviz_nbclust(sig_genes_mat, kmeans, method = "silhouette")
)
```

Two clusters seems to be the consensus optimal number of clusters.
This indicates that the mode of action is very similar for those, only the degree
of regulation (i.e. FC) is different. This could be a consequence of slightly 
different cultivation conditions, such as growth rate or generation time for the 
individual sgRNA mutant turbidostats.

```{r, fig.width = 8, fig.height = 2.5}
# computing clusters with same method as in heatmap
# we omit re-scaling the data as we assume it is already scaled by DESeq2
clusters <- sig_genes_mat %>% dist %>% 
  hclust(method = "ward.D2") %>% cutree(k = 2)

plot_clusters <- fviz_dend(sig_genes_mat %>% dist %>%
  hclust(method = "ward.D2"), k = 2, main = "",
  k_colors = custom.lattice()$superpose.symbol$col[1:2],
  show_labels = FALSE
)

print(plot_clusters)
```

Next we can look if there are any genes enriched for specific pathways 
for the complete group of differentially expressed genes, or within each individual 
cluster. For the first task, there was a slight but not very significant enrichment
of amino acid synthesis pathways. The enrichment is not very significant because
the number of differentially expressed genes is low. For the second task, also only
few pathways are enriched per cluster.

```{r, message = FALSE}
# Gene enrichment methods for the selected gene subset
# 1. KEGG module enrichment for list of sig reg genes
sig_genes %>% enrichMKEGG(organism = 'syn', minGSSize = 1,
  pvalueCutoff = 1, qvalueCutoff = 1) %>%
  {.@result %>% filter(Count >= 2)}

# This result is not meaningful, there are no more than 2 
# genes per module enriched. 
# 2. KEGG pathway enrichment using kegga

sig_genes %>% kegga(species.KEGG = "syn", FDR = 0.05, trend = FALSE) %>%
  arrange(P.DE) %>% filter(P.DE <= 0.1)

# 3. Trying pathway enrichment for specific clusters 1 and 2.
kegga_result <- clusters %>% 
  enframe(name = "protein", value = "cluster") %>%
  
  plyr::dlply(.variables = 'cluster', function(x)  x$protein) %>%
    kegga(species.KEGG = "syn", FDR = 0.05, trend = FALSE) %>%
  filter_at(vars(starts_with("P.")), any_vars(. <= 0.05))

print(kegga_result)
```


```{r, message = FALSE, fig.width = 6, fig.height = 2.25}
# plot the resut
kegga_result %>% select(Pathway, P.1:P.2) %>% rename(up = P.1, down = P.2) %>%
  
  # turn into matrix
  column_to_rownames("Pathway") %>% as.matrix %>% {t(.)} %>%
  
  # plot result as heatmap again
  levelplot(
    col.regions = colorRampPalette(c("steelblue", grey(0.9)))(11),
    as.table = TRUE, aspect = "fill", at = seq(0, 0.1, 0.01),
    xlab = "cluster", ylab = ""
  )
```

---------

#### Network analysis

Two more strategies can be applied to find biologically interesting patterns
or even just hypothesis for the change in growth rate of mutants _versus_ control.
One of those is network interaction analysis of sig. regulated genes, and the 
other is simply looking at interesting candidates that alone can have an effect.
Known examples for genes with positive effect (or at least correlation) on growth 
rate would be ribosomal genes, central carbon metabolism enzymes or ATP synthase 
(references).


```{r, message = FALSE}
# We create a new data frame with a selection of all interesting genes from cluster
# 1 and 2 to be used for String DB, or simple heatmap plotting
df_sig_genes <- clusters %>% 
  enframe(name = "locus", value = "cluster") %>%
  
  # join cluster data with RNAseq data
  left_join(df_rnaseq %>% 
    select(Name, Condition, log2FoldChange, padj, Pathway, Protein) %>% 
    rename(locus = Name)) %>%
  
  # join with additional annotation
  left_join(df %>% ungroup %>%
    select(locus, Process, Process.abbr, Gene.names) %>%
    filter(!duplicated(locus))) %>%
  
  arrange(cluster, Condition, log2FoldChange)

#write_csv(df_sig_genes, "../processed_data/Supplemental_data_S6.csv")
```


---------

#### Differential expression of selected genes

First we can make a table of the genes that are down-regulated in several 
conditions, in the same direction. This requires to omit the p-value criterium
for now, as many genes might have the same direction of regulation 
(as shown in heat map) but are not significant as the fold change is too little.

```{r}
df_sig_genes_filtered <- df_sig_genes %>%
  
  # summarize number of conditions (mutants) where gene appears to be regulated
  group_by(locus) %>%
  summarize(
    up_reg = sum(log2FoldChange >= log2(1.5)),
    down_reg = sum(log2FoldChange <= log2(1/1.5)),
    mean_log2_FC = mean(log2FoldChange),
    Gene.names = Gene.names[1] %>% gsub("s[sl][rl][0-9]{4}", "", .),
    Protein = Protein[1] %>% substr(1, 50)
  ) %>%
  
  # sort by number of down-regulated samples
  filter(up_reg >= 3 | down_reg >= 3) %>%
  arrange(desc(up_reg), desc(down_reg), desc(mean_log2_FC))

df_sig_genes_filtered
#   write_csv(df_sig_genes_filtered, "~/Desktop/reg_genes_FC1_5.csv")
```

----------

Next, we simply plot the most interesting genes as heatmap
or correlation plot using the `corrplot` package. 


```{r}
# select only consensus regulated genes (exclude pmgA, cluster 1+3)
# and annotated genes
plot_sig_genes <- lapply(1:2, function(clust) {
  
  df_sig_genes %>% filter(cluster == clust, !is.na(Pathway)) %>%
  
  # merge pathway and gene name
  mutate(Gene.names = paste0(substr(Pathway, 1,10), ".. - ", Gene.names)) %>%
  select(Gene.names, Condition, log2FoldChange) %>% 
  
  # spread
  spread(Condition, log2FoldChange) %>% 
  select(Gene.names, sll1969, slr1340, slr1916, ssl2982) %>%
  
  # and convert to matrix
  column_to_rownames("Gene.names") %>% as.matrix %>%

  # plot 
  levelplot(
    col.regions = colorRampPalette(c("steelblue", grey(0.95), "darkorange"))(26),
    as.table = TRUE, aspect = "fill", at = seq(-3, 3, 0.25),
    xlab = "", ylab = "",
    scales = list(x = list(rot = 35, cex = 0.6, col = grey(0.5)))
  )
  
})

print(plot_sig_genes[[1]], position = c(0,0.5,1,1), more = TRUE)
print(plot_sig_genes[[2]], position = c(0,0,1,0.5))
```

An alternative is to plot genes per group in form of a dotplot instead of heatmap.
The focus here should be on functional groups instead of single genes. Even more
concise is a simple barchart summary of up and down-regulated gene per group.

```{r, fig.width = 8, fig.height = 4}
# genes of particular interest
selected_genes <- df_sig_genes %>% 
  filter(log2FoldChange >= 2 | log2FoldChange <= -2) %>%
  pull(locus) %>% unique
selected_genes <- c(selected_genes, "sll1316", 
   "sll1796", "slr1291", "slr2007", "sll1732",
   "ssr2016", "slr0940", "slr1254", "sll1541",
   "slr0947", "slr0081", "slr2034", "sll0617",
   "slr0749", "slr0750", "slr0506", "sll1969")

plot_dots <- xyplot(factor(Process.abbr) ~ setNames(log2FoldChange, locus) | 
      factor(Condition), df_sig_genes, as.table = TRUE, 
    xlab = bquote(log[2] ~ "FC"), ylab = "",
    par.settings = custom.lattice, layout = c(4, 1),
    scales = list(alternating = FALSE), xlim = c(-6, 6),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(v = 0, lwd = 1.5, lty = 2, col = grey(0.5))
      cols = scales::rescale(x, from = c(-3, 3), to = c(1, 20)) %>%
        replace(., . < 1, 1) %>% replace(., .> 20, 20)
      cols = colorRampPalette(c("steelblue", grey(0.7), "darkorange"))(20)[round(cols)]
      panel.xyplot(x, y, pch = 19, cex = 0.6+(0.4*abs(x)), col = cols)
      sel <- which(names(x) %in% selected_genes & (x >= 1 | x <= -1))
      panel.xyplot(x[sel], y[sel], cex = 1.2+(0.4*abs(x[sel])), col = grey(0.3))
      panel.text(x[sel], y[sel], labels = names(sel), cex = 0.6, col = grey(0.3),
        pos = 3, offset = -2)
    }
  )

print(plot_dots)
```


```{r, fig.width = 8, fig.height = 4}
df_sig_genes %>% 
  
  # summarize number of genes up or down regulated
  group_by(Condition, Process.abbr) %>%
  summarize(
    n_upreg_genes = sum(log2FoldChange > 1),
    n_downreg_genes = sum(log2FoldChange < -1)
  ) %>%
  
  barchart(factor(Process.abbr) ~ n_upreg_genes + -1*n_downreg_genes | 
      factor(Condition), .,
    col = c("darkorange", "steelblue"), border = NA,
    as.table = TRUE, 
    xlab = bquote("diff. expressed genes" ~ (-1 >= log[2]~"FC" >= 1)), ylab = "",
    par.settings = custom.lattice, layout = c(4, 1), xlim = c(-20, 20),
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(v = 0, lwd = 1.5, lty = 2, col = grey(0.5))
      panel.barchart(x, y, origin = 0, ...)
    }
  )
```


----------

This is going to be Figure 4, the summary of the transcriptomics part.

```{r, fig.width = 6.5, fig.height = 8.3}
print(plot_mutant_mu[[1]], position = c(0,0.77,1,1.03), more = TRUE)
print(plot_volcanoplot, position = c(0,0.56,1,0.84), more = TRUE)
print(plot_heatmap, position = c(0.037,0.44,0.987,0.59), more = TRUE)
print(plot_dots, position = c(0,0,1,0.484))
grid.text(label = c("a", "b", "c", "d"), x = rep(0.03, 4), 
  y = c(0.98, 0.8, 0.57, 0.44), gp = gpar(cex = 1.3))
```

----------

**Figure 4. Transcriptomics of faster growing sgRNA mutants.**
The faster growing mutants pmgA (sll1968), sll1969, slr1340, slr1916, and ssl2982 
were grown in high light conditions (300 µmol photons m<sup>-2</sup> s<sup>-1</sup>)
in turbidostat regime identical to the conditions that the complete mutant 
library was grown before. sgRNA expression was induced by adding aTC. 
The transcriptome of the cells was analyzed using RNA-Seq.
**a** Enrichment of fastest-growing sgRNA mutants in competition experiments 
(log<sub>2</sub> fold change (log<sub>2</sub> FC) over time).
**b** Volcanoplot of log<sub>2</sub> FC against adjusted p-value for each gene. 
Grey - non-significantly different genes, blue - significantly different genes (threshold: negative log<sub>10</sub> p-value $\geq$ 2, -1 $\geq$ log<sub>2</sub> FC $\geq$ 1). 
The p-value for three sgRNA mutants was outside the plotting region and was 
restricted to -log<sub>10</sub> p-value of 50 for visibility.
**c** Heat map of all 305 significantly different genes for the four selected mutants.
The genes were clustered into two different groups based on similarity of gene expression.
**d** Significantly different genes broken down by cyanobase pathways. Genes of particular 
interest were highlighted (see text for details). Blue color indicates negative and 
orange color positive log<sub>2</sub> FC, respectively.


```{r, include = FALSE, eval = FALSE}
svg("../figures/main/Figure4_raw.svg", width = 6.5, height = 8.3)
print(plot_mutant_mu[[1]], position = c(0,0.77,1,1.03), more = TRUE)
print(plot_volcanoplot, position = c(0,0.56,1,0.84), more = TRUE)
print(plot_heatmap, position = c(0.037,0.44,0.987,0.59), more = TRUE)
print(plot_dots, position = c(0,0,1,0.484))
grid.text(label = c("a", "b", "c", "d"), x = rep(0.03, 4), 
  y = c(0.98, 0.8, 0.57, 0.44), gp = gpar(cex = 1.3))
dev.off()
```


## Droplet sorting of lactate over-producing strains

The sgRNA mutant library was grown in presence of inducer, encapsulated in 
microfluidic droplets and injected with a fluorecent reagent to monitor
lactate production over time. Highly fluorescent droplets were then sorted
and recovered, the sgRNA amplified by PCR and sequenced by NGS. The following
plot shows lactate production over time by selected over-producing sgRNA mutants.


```{r, message = FALSE, error = FALSE}
# original data was re-organized to long format
df_lac_prod <- bind_rows(.id = "setup",
  read_csv("../raw_data/lactate_measurement_mutants.csv"),
  read_csv("../raw_data/lactate_measurement_mutants_2.csv")
)

# add µmol/L*OD720 and per gDCW (using 0.4 gDCW/OD720)
df_lac_prod <- df_lac_prod %>%
  
  mutate(
    lactate_µmol_L_OD = lactate_µmol_L / OD_720,
    lactate_µmol_L_gDCW = lactate_µmol_L_OD * 0.4
  ) %>%
  
  mutate(setup = recode(setup, 
    `1` = "shake flask", 
    `2` = "photonfluxostat"))
  
# preview data
df_lac_prod
```


```{r, fig.width = 5.5, fig.height = 5.5}
# list of combinations
combinations <- list(
  unit = rep(c("lactate_µmol_L", "lactate_µmol_L_OD"), 2),
  setup = rep(c("shake flask", "photonfluxostat"), each = 2)
)

# dot plot
plot_lac_prod <- lapply(1:4, function(i) {
  
  # color depending on number of strains
  df <- filter(df_lac_prod, setup == combinations$setup[i])
  col = colorspace::rainbow_hcl(8,  start = 30, l = 50, c = 60)
  if (i %in% c(1,2)) {
    col = c(col, grey(0.5))
  } else {
    col = c(col[c(5,1,8)], grey(0.5))
  }
  
  xyplot(get(combinations$unit[i]) ~ factor(time_h), df,
    groups = factor(strain, unique(strain)), as.table = TRUE,
    col = col,
    xlab = ifelse(i %in% c(3, 4), "time [h]", ""), 
    ylab = ifelse(i %in% c(1, 3), "µmol L-1", "µmol L-1 OD720-1"),
    par.settings = custom.lattice, type = "b", pch = 19,
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.superpose(x, y, ...)
      if (i %in% c(1, 3)) {
        panel.key(unique(df$strain), col = col, points = FALSE, cex = 0.7)
      }
    },
    panel.groups = function(x, y, ...) {
      panel.errbars(x, y, ewidth = 0, ...)
    }
  )
})

print(plot_lac_prod[[1]], position = c(0,0.49,0.53,1), more = TRUE)
print(plot_lac_prod[[2]], position = c(0.47,0.49,1,1), more = TRUE)
print(plot_lac_prod[[3]], position = c(0.015,0,0.53,0.53), more = TRUE)
print(plot_lac_prod[[4]], position = c(0.47,0,1,0.53))
grid.text(label = c("shake flask", "'photonfluxostat'"), x = c(0.5, 0.5),
  y = c(0.97, 0.5), gp = gpar(cex = 1))
grid.text(label = c("a", "b"), x = c(0.03, 0.03), 
  y = c(0.97, 0.5), gp = gpar(cex = 1.3))
```

----------

**Figure 6. Strains with increased lactate production.**
Strains with potentially increased lactate productivity were discovered
using a fluorescence activated droplet sorting assay. Selected mutants were 
re-constructed, cultivated, and product titer determined in µmol per Liter, and 
µmol per Liter per biomass (OD720).
**a** Top eight enriched mutants cultivated in axenic shake flask cultures. 
Lactate concentration was measured after 24 and 48 hours. 
NT0 - control with sgRNA targeting neutral region.
**b** A subset of three mutants (excluding the known over-producer _gltA_) was cultivated 
in axenic 'photonfluxostat' cultures (light intensity proportional to cell density).
Lactate concentration was measured after 18 and 30 hours. 

----------

```{r, eval = FALSE, include = FALSE}
# export potential Figure 6
svg("../figures/main/Figure6.svg", width = 5.5, height = 5.5)
print(plot_lac_prod[[1]], position = c(0,0.49,0.53,1), more = TRUE)
print(plot_lac_prod[[2]], position = c(0.47,0.49,1,1), more = TRUE)
print(plot_lac_prod[[3]], position = c(0.015,0,0.53,0.53), more = TRUE)
print(plot_lac_prod[[4]], position = c(0.47,0,1,0.53))
grid.text(label = c("shake flask", "'photonfluxostat'"), x = c(0.5, 0.5),
  y = c(0.97, 0.5), gp = gpar(cex = 1))
grid.text(label = c("a", "b"), x = c(0.03, 0.03), 
  y = c(0.97, 0.5), gp = gpar(cex = 1.3))
dev.off()
```


We can also have a look at relative increase in % productivity compared to NT0
control.


```{r}
df_lac_prod %>% filter(time_h != 0) %>%
  
  group_by(setup, time_h, strain) %>%
  summarize(mean_lac = mean(lactate_µmol_L_OD)) %>%
  mutate(mean_lac_percent = mean_lac/mean_lac[1])
```

